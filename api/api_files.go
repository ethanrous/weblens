/*
Weblens API

Programmatic access to the Weblens server

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// FilesAPIService FilesAPI service
type FilesAPIService service

type ApiAddFilesToUploadRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	uploadID string
	request *NewFilesParams
	shareID *string
}

// New file params
func (r ApiAddFilesToUploadRequest) Request(request NewFilesParams) ApiAddFilesToUploadRequest {
	r.request = &request
	return r
}

// Share ID
func (r ApiAddFilesToUploadRequest) ShareID(shareID string) ApiAddFilesToUploadRequest {
	r.shareID = &shareID
	return r
}

func (r ApiAddFilesToUploadRequest) Execute() (*NewFilesInfo, *http.Response, error) {
	return r.ApiService.AddFilesToUploadExecute(r)
}

/*
AddFilesToUpload Add a file to an upload task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadID Upload ID
 @return ApiAddFilesToUploadRequest
*/
func (a *FilesAPIService) AddFilesToUpload(ctx context.Context, uploadID string) ApiAddFilesToUploadRequest {
	return ApiAddFilesToUploadRequest{
		ApiService: a,
		ctx: ctx,
		uploadID: uploadID,
	}
}

// Execute executes the request
//  @return NewFilesInfo
func (a *FilesAPIService) AddFilesToUploadExecute(r ApiAddFilesToUploadRequest) (*NewFilesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewFilesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.AddFilesToUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upload/{uploadID}"
	localVarPath = strings.Replace(localVarPath, "{"+"uploadID"+"}", url.PathEscape(parameterValueToString(r.uploadID, "uploadID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAutocompletePathRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	searchPath *string
}

// Search path
func (r ApiAutocompletePathRequest) SearchPath(searchPath string) ApiAutocompletePathRequest {
	r.searchPath = &searchPath
	return r
}

func (r ApiAutocompletePathRequest) Execute() (*FolderInfo, *http.Response, error) {
	return r.ApiService.AutocompletePathExecute(r)
}

/*
AutocompletePath Get path completion suggestions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAutocompletePathRequest
*/
func (a *FilesAPIService) AutocompletePath(ctx context.Context) ApiAutocompletePathRequest {
	return ApiAutocompletePathRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolderInfo
func (a *FilesAPIService) AutocompletePathExecute(r ApiAutocompletePathRequest) (*FolderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.AutocompletePath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/autocomplete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchPath == nil {
		return localVarReturnValue, nil, reportError("searchPath is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "searchPath", r.searchPath, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClearZipCacheRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
}

func (r ApiClearZipCacheRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearZipCacheExecute(r)
}

/*
ClearZipCache Clear all cached zip files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClearZipCacheRequest
*/
func (a *FilesAPIService) ClearZipCache(ctx context.Context) ApiClearZipCacheRequest {
	return ApiClearZipCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilesAPIService) ClearZipCacheExecute(r ApiClearZipCacheRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.ClearZipCache")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/takeout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateTakeoutRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	request *FilesListParams
	shareID *string
}

// File Ids
func (r ApiCreateTakeoutRequest) Request(request FilesListParams) ApiCreateTakeoutRequest {
	r.request = &request
	return r
}

// Share ID
func (r ApiCreateTakeoutRequest) ShareID(shareID string) ApiCreateTakeoutRequest {
	r.shareID = &shareID
	return r
}

func (r ApiCreateTakeoutRequest) Execute() (*TakeoutInfo, *http.Response, error) {
	return r.ApiService.CreateTakeoutExecute(r)
}

/*
CreateTakeout Create a zip file

Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTakeoutRequest
*/
func (a *FilesAPIService) CreateTakeout(ctx context.Context) ApiCreateTakeoutRequest {
	return ApiCreateTakeoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TakeoutInfo
func (a *FilesAPIService) CreateTakeoutExecute(r ApiCreateTakeoutRequest) (*TakeoutInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TakeoutInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.CreateTakeout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/takeout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	request *FilesListParams
	ignoreTrash *bool
	preserveFolder *bool
}

// Delete files request body
func (r ApiDeleteFilesRequest) Request(request FilesListParams) ApiDeleteFilesRequest {
	r.request = &request
	return r
}

// Delete files even if they are not in the trash
func (r ApiDeleteFilesRequest) IgnoreTrash(ignoreTrash bool) ApiDeleteFilesRequest {
	r.ignoreTrash = &ignoreTrash
	return r
}

// Preserve parent folder if it is empty after deletion
func (r ApiDeleteFilesRequest) PreserveFolder(preserveFolder bool) ApiDeleteFilesRequest {
	r.preserveFolder = &preserveFolder
	return r
}

func (r ApiDeleteFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFilesExecute(r)
}

/*
DeleteFiles Delete Files \"permanently\"

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFilesRequest
*/
func (a *FilesAPIService) DeleteFiles(ctx context.Context) ApiDeleteFilesRequest {
	return ApiDeleteFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilesAPIService) DeleteFilesExecute(r ApiDeleteFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.DeleteFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.ignoreTrash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreTrash", r.ignoreTrash, "", "")
	}
	if r.preserveFolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserveFolder", r.preserveFolder, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileID string
	shareID *string
	format *string
	quality *int32
	isTakeout *bool
}

// Share ID
func (r ApiDownloadFileRequest) ShareID(shareID string) ApiDownloadFileRequest {
	r.shareID = &shareID
	return r
}

// File format conversion
func (r ApiDownloadFileRequest) Format(format string) ApiDownloadFileRequest {
	r.format = &format
	return r
}

// JPEG quality (1-100)
func (r ApiDownloadFileRequest) Quality(quality int32) ApiDownloadFileRequest {
	r.quality = &quality
	return r
}

// Is this a takeout file
func (r ApiDownloadFileRequest) IsTakeout(isTakeout bool) ApiDownloadFileRequest {
	r.isTakeout = &isTakeout
	return r
}

func (r ApiDownloadFileRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DownloadFileExecute(r)
}

/*
DownloadFile Download a file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileID File ID
 @return ApiDownloadFileRequest
*/
func (a *FilesAPIService) DownloadFile(ctx context.Context, fileID string) ApiDownloadFileRequest {
	return ApiDownloadFileRequest{
		ApiService: a,
		ctx: ctx,
		fileID: fileID,
	}
}

// Execute executes the request
//  @return string
func (a *FilesAPIService) DownloadFileExecute(r ApiDownloadFileRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.DownloadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/{fileID}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"fileID"+"}", url.PathEscape(parameterValueToString(r.fileID, "fileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "", "")
	} else {
		var defaultValue int32 = 85
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", defaultValue, "", "")
		r.quality = &defaultValue
	}
	if r.isTakeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isTakeout", r.isTakeout, "", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "isTakeout", defaultValue, "", "")
		r.isTakeout = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WeblensErrorInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileID string
	shareID *string
}

// Share ID
func (r ApiGetFileRequest) ShareID(shareID string) ApiGetFileRequest {
	r.shareID = &shareID
	return r
}

func (r ApiGetFileRequest) Execute() (*FileInfo, *http.Response, error) {
	return r.ApiService.GetFileExecute(r)
}

/*
GetFile Get information about a file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileID File ID
 @return ApiGetFileRequest
*/
func (a *FilesAPIService) GetFile(ctx context.Context, fileID string) ApiGetFileRequest {
	return ApiGetFileRequest{
		ApiService: a,
		ctx: ctx,
		fileID: fileID,
	}
}

// Execute executes the request
//  @return FileInfo
func (a *FilesAPIService) GetFileExecute(r ApiGetFileRequest) (*FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/{fileID}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileID"+"}", url.PathEscape(parameterValueToString(r.fileID, "fileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileStatsRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileID string
}

func (r ApiGetFileStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFileStatsExecute(r)
}

/*
GetFileStats Get the statistics of a file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileID File ID
 @return ApiGetFileStatsRequest
*/
func (a *FilesAPIService) GetFileStats(ctx context.Context, fileID string) ApiGetFileStatsRequest {
	return ApiGetFileStatsRequest{
		ApiService: a,
		ctx: ctx,
		fileID: fileID,
	}
}

// Execute executes the request
func (a *FilesAPIService) GetFileStatsExecute(r ApiGetFileStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFileStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/{fileID}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"fileID"+"}", url.PathEscape(parameterValueToString(r.fileID, "fileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFileTextRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileID string
	shareID *string
}

// Share ID
func (r ApiGetFileTextRequest) ShareID(shareID string) ApiGetFileTextRequest {
	r.shareID = &shareID
	return r
}

func (r ApiGetFileTextRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetFileTextExecute(r)
}

/*
GetFileText Get the text of a text file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileID File ID
 @return ApiGetFileTextRequest
*/
func (a *FilesAPIService) GetFileText(ctx context.Context, fileID string) ApiGetFileTextRequest {
	return ApiGetFileTextRequest{
		ApiService: a,
		ctx: ctx,
		fileID: fileID,
	}
}

// Execute executes the request
//  @return string
func (a *FilesAPIService) GetFileTextExecute(r ApiGetFileTextRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFileText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/{fileID}/text"
	localVarPath = strings.Replace(localVarPath, "{"+"fileID"+"}", url.PathEscape(parameterValueToString(r.fileID, "fileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSharedFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
}

func (r ApiGetSharedFilesRequest) Execute() (*FolderInfo, *http.Response, error) {
	return r.ApiService.GetSharedFilesExecute(r)
}

/*
GetSharedFiles Get files shared with the logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSharedFilesRequest
*/
func (a *FilesAPIService) GetSharedFiles(ctx context.Context) ApiGetSharedFilesRequest {
	return ApiGetSharedFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolderInfo
func (a *FilesAPIService) GetSharedFilesExecute(r ApiGetSharedFilesRequest) (*FolderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetSharedFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/shared"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUploadResultRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	uploadID string
}

func (r ApiGetUploadResultRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUploadResultExecute(r)
}

/*
GetUploadResult Get the result of an upload task. This will block until the upload is complete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadID Upload ID
 @return ApiGetUploadResultRequest
*/
func (a *FilesAPIService) GetUploadResult(ctx context.Context, uploadID string) ApiGetUploadResultRequest {
	return ApiGetUploadResultRequest{
		ApiService: a,
		ctx: ctx,
		uploadID: uploadID,
	}
}

// Execute executes the request
func (a *FilesAPIService) GetUploadResultExecute(r ApiGetUploadResultRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetUploadResult")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upload/{uploadID}"
	localVarPath = strings.Replace(localVarPath, "{"+"uploadID"+"}", url.PathEscape(parameterValueToString(r.uploadID, "uploadID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMoveFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	request *MoveFilesParams
	shareID *string
}

// Move files request body
func (r ApiMoveFilesRequest) Request(request MoveFilesParams) ApiMoveFilesRequest {
	r.request = &request
	return r
}

// Share ID
func (r ApiMoveFilesRequest) ShareID(shareID string) ApiMoveFilesRequest {
	r.shareID = &shareID
	return r
}

func (r ApiMoveFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveFilesExecute(r)
}

/*
MoveFiles Move a list of files to a new parent folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoveFilesRequest
*/
func (a *FilesAPIService) MoveFiles(ctx context.Context) ApiMoveFilesRequest {
	return ApiMoveFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilesAPIService) MoveFilesExecute(r ApiMoveFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.MoveFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRestoreFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	request *RestoreFilesBody
}

// RestoreFiles files request body
func (r ApiRestoreFilesRequest) Request(request RestoreFilesBody) ApiRestoreFilesRequest {
	r.request = &request
	return r
}

func (r ApiRestoreFilesRequest) Execute() (*RestoreFilesInfo, *http.Response, error) {
	return r.ApiService.RestoreFilesExecute(r)
}

/*
RestoreFiles structsore files from some time in the past

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestoreFilesRequest
*/
func (a *FilesAPIService) RestoreFiles(ctx context.Context) ApiRestoreFilesRequest {
	return ApiRestoreFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RestoreFilesInfo
func (a *FilesAPIService) RestoreFilesExecute(r ApiRestoreFilesRequest) (*RestoreFilesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreFilesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.RestoreFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/structsore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchByFilenameRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	search *string
	baseFolderID *string
	sortProp *string
	sortOrder *string
	recursive *bool
	regex *bool
}

// Filename to search for
func (r ApiSearchByFilenameRequest) Search(search string) ApiSearchByFilenameRequest {
	r.search = &search
	return r
}

// The folder to search in, defaults to the user&#39;s home folder
func (r ApiSearchByFilenameRequest) BaseFolderID(baseFolderID string) ApiSearchByFilenameRequest {
	r.baseFolderID = &baseFolderID
	return r
}

// Property to sort by
func (r ApiSearchByFilenameRequest) SortProp(sortProp string) ApiSearchByFilenameRequest {
	r.sortProp = &sortProp
	return r
}

// Sort order
func (r ApiSearchByFilenameRequest) SortOrder(sortOrder string) ApiSearchByFilenameRequest {
	r.sortOrder = &sortOrder
	return r
}

// Search recursively
func (r ApiSearchByFilenameRequest) Recursive(recursive bool) ApiSearchByFilenameRequest {
	r.recursive = &recursive
	return r
}

// Whether to treat the search term as a regex pattern
func (r ApiSearchByFilenameRequest) Regex(regex bool) ApiSearchByFilenameRequest {
	r.regex = &regex
	return r
}

func (r ApiSearchByFilenameRequest) Execute() ([]FileInfo, *http.Response, error) {
	return r.ApiService.SearchByFilenameExecute(r)
}

/*
SearchByFilename Search for files by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchByFilenameRequest
*/
func (a *FilesAPIService) SearchByFilename(ctx context.Context) ApiSearchByFilenameRequest {
	return ApiSearchByFilenameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FileInfo
func (a *FilesAPIService) SearchByFilenameExecute(r ApiSearchByFilenameRequest) ([]FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.SearchByFilename")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.search == nil {
		return localVarReturnValue, nil, reportError("search is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "", "")
	if r.baseFolderID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseFolderID", r.baseFolderID, "", "")
	}
	if r.sortProp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortProp", r.sortProp, "", "")
	} else {
		var defaultValue string = "name"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortProp", defaultValue, "", "")
		r.sortProp = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "", "")
		r.sortOrder = &defaultValue
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", defaultValue, "", "")
		r.recursive = &defaultValue
	}
	if r.regex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regex", r.regex, "", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "regex", defaultValue, "", "")
		r.regex = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartUploadRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	request *NewUploadParams
	shareID *string
}

// New upload request body
func (r ApiStartUploadRequest) Request(request NewUploadParams) ApiStartUploadRequest {
	r.request = &request
	return r
}

// Share ID
func (r ApiStartUploadRequest) ShareID(shareID string) ApiStartUploadRequest {
	r.shareID = &shareID
	return r
}

func (r ApiStartUploadRequest) Execute() (*NewUploadInfo, *http.Response, error) {
	return r.ApiService.StartUploadExecute(r)
}

/*
StartUpload Begin a new upload task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStartUploadRequest
*/
func (a *FilesAPIService) StartUpload(ctx context.Context) ApiStartUploadRequest {
	return ApiStartUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NewUploadInfo
func (a *FilesAPIService) StartUploadExecute(r ApiStartUploadRequest) (*NewUploadInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewUploadInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.StartUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnTrashFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	request *FilesListParams
}

// Un-trash files request body
func (r ApiUnTrashFilesRequest) Request(request FilesListParams) ApiUnTrashFilesRequest {
	r.request = &request
	return r
}

func (r ApiUnTrashFilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnTrashFilesExecute(r)
}

/*
UnTrashFiles Move a list of files out of the trash, structsoring them to where they were before

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnTrashFilesRequest
*/
func (a *FilesAPIService) UnTrashFiles(ctx context.Context) ApiUnTrashFilesRequest {
	return ApiUnTrashFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilesAPIService) UnTrashFilesExecute(r ApiUnTrashFilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.UnTrashFiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/untrash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileID string
	request *UpdateFileParams
	shareID *string
}

// Update file request body
func (r ApiUpdateFileRequest) Request(request UpdateFileParams) ApiUpdateFileRequest {
	r.request = &request
	return r
}

// Share ID
func (r ApiUpdateFileRequest) ShareID(shareID string) ApiUpdateFileRequest {
	r.shareID = &shareID
	return r
}

func (r ApiUpdateFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFileExecute(r)
}

/*
UpdateFile Update a File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileID File ID
 @return ApiUpdateFileRequest
*/
func (a *FilesAPIService) UpdateFile(ctx context.Context, fileID string) ApiUpdateFileRequest {
	return ApiUpdateFileRequest{
		ApiService: a,
		ctx: ctx,
		fileID: fileID,
	}
}

// Execute executes the request
func (a *FilesAPIService) UpdateFileExecute(r ApiUpdateFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.UpdateFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/{fileID}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileID"+"}", url.PathEscape(parameterValueToString(r.fileID, "fileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadFileChunkRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	uploadID string
	fileID string
	chunk *os.File
	shareID *string
}

// File chunk
func (r ApiUploadFileChunkRequest) Chunk(chunk *os.File) ApiUploadFileChunkRequest {
	r.chunk = chunk
	return r
}

// Share ID
func (r ApiUploadFileChunkRequest) ShareID(shareID string) ApiUploadFileChunkRequest {
	r.shareID = &shareID
	return r
}

func (r ApiUploadFileChunkRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadFileChunkExecute(r)
}

/*
UploadFileChunk Add a chunk to a file upload

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadID Upload ID
 @param fileID File ID
 @return ApiUploadFileChunkRequest
*/
func (a *FilesAPIService) UploadFileChunk(ctx context.Context, uploadID string, fileID string) ApiUploadFileChunkRequest {
	return ApiUploadFileChunkRequest{
		ApiService: a,
		ctx: ctx,
		uploadID: uploadID,
		fileID: fileID,
	}
}

// Execute executes the request
func (a *FilesAPIService) UploadFileChunkExecute(r ApiUploadFileChunkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.UploadFileChunk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upload/{uploadID}/file/{fileID}"
	localVarPath = strings.Replace(localVarPath, "{"+"uploadID"+"}", url.PathEscape(parameterValueToString(r.uploadID, "uploadID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fileID"+"}", url.PathEscape(parameterValueToString(r.fileID, "fileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chunk == nil {
		return nil, reportError("chunk is required and must be specified")
	}

	if r.shareID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareID", r.shareID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var chunkLocalVarFormFileName string
	var chunkLocalVarFileName     string
	var chunkLocalVarFileBytes    []byte

	chunkLocalVarFormFileName = "chunk"
	chunkLocalVarFile := r.chunk

	if chunkLocalVarFile != nil {
		fbs, _ := io.ReadAll(chunkLocalVarFile)

		chunkLocalVarFileBytes = fbs
		chunkLocalVarFileName = chunkLocalVarFile.Name()
		chunkLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: chunkLocalVarFileBytes, fileName: chunkLocalVarFileName, formFileName: chunkLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
