/* tslint:disable */
/* eslint-disable */
/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddUserParams
 */
export interface AddUserParams {
    /**
     * 
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canView'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddUserParams
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ApiKeyParams
 */
export interface ApiKeyParams {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyParams
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BackupInfo
 */
export interface BackupInfo {
    /**
     * 
     * @type {Array<FileActionInfo>}
     * @memberof BackupInfo
     */
    'fileHistory'?: Array<FileActionInfo>;
    /**
     * 
     * @type {Array<TowerInfo>}
     * @memberof BackupInfo
     */
    'instances'?: Array<TowerInfo>;
    /**
     * 
     * @type {number}
     * @memberof BackupInfo
     */
    'lifetimesCount'?: number;
    /**
     * 
     * @type {Array<TokenInfo>}
     * @memberof BackupInfo
     */
    'tokens'?: Array<TokenInfo>;
    /**
     * 
     * @type {Array<UserInfoArchive>}
     * @memberof BackupInfo
     */
    'users'?: Array<UserInfoArchive>;
}
/**
 * 
 * @export
 * @interface CreateFolderBody
 */
export interface CreateFolderBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateFolderBody
     */
    'children'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderBody
     */
    'newFolderName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderBody
     */
    'parentFolderId': string;
}
/**
 * 
 * @export
 * @interface FileActionInfo
 */
export interface FileActionInfo {
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'actionType': string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'destinationPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'fileId': string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'filepath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'originPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'parentId': string;
    /**
     * 
     * @type {number}
     * @memberof FileActionInfo
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof FileActionInfo
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof FileActionInfo
     */
    'towerId': string;
}
/**
 * 
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof FileInfo
     */
    'childrenIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'currentId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileInfo
     */
    'hasRestoreMedia'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileInfo
     */
    'isDir'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileInfo
     */
    'modifiable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FileInfo
     */
    'modifyTimestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'parentId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileInfo
     */
    'pastFile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'portablePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'shareId'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileInfo
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface FileShareParams
 */
export interface FileShareParams {
    /**
     * 
     * @type {string}
     * @memberof FileShareParams
     */
    'fileId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileShareParams
     */
    'public'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileShareParams
     */
    'timelineOnly'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof FileShareParams
     */
    'users'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FileShareParams
     */
    'wormhole'?: boolean;
}
/**
 * 
 * @export
 * @interface FilesListParams
 */
export interface FilesListParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof FilesListParams
     */
    'fileIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FolderInfo
 */
export interface FolderInfo {
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof FolderInfo
     */
    'children'?: Array<FileInfo>;
    /**
     * 
     * @type {Array<MediaInfo>}
     * @memberof FolderInfo
     */
    'medias'?: Array<MediaInfo>;
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof FolderInfo
     */
    'parents'?: Array<FileInfo>;
    /**
     * 
     * @type {FileInfo}
     * @memberof FolderInfo
     */
    'self'?: FileInfo;
}
/**
 * 
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     * 
     * @type {string}
     * @memberof LoginBody
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof LoginBody
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface MediaBatchInfo
 */
export interface MediaBatchInfo {
    /**
     * 
     * @type {Array<MediaInfo>}
     * @memberof MediaBatchInfo
     */
    'Media'?: Array<MediaInfo>;
    /**
     * 
     * @type {number}
     * @memberof MediaBatchInfo
     */
    'mediaCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaBatchInfo
     */
    'totalMediaCount'?: number;
}
/**
 * 
 * @export
 * @interface MediaBatchParams
 */
export interface MediaBatchParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaBatchParams
     */
    'folderIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MediaBatchParams
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MediaBatchParams
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaBatchParams
     */
    'mediaIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MediaBatchParams
     */
    'page'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MediaBatchParams
     */
    'raw'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaBatchParams
     */
    'search'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaBatchParams
     */
    'sort'?: MediaBatchParamsSortEnum;
    /**
     * 
     * @type {number}
     * @memberof MediaBatchParams
     */
    'sortDirection'?: number;
}

export const MediaBatchParamsSortEnum = {
    CreateDate: 'createDate'
} as const;

export type MediaBatchParamsSortEnum = typeof MediaBatchParamsSortEnum[keyof typeof MediaBatchParamsSortEnum];

/**
 * 
 * @export
 * @interface MediaIdsParams
 */
export interface MediaIdsParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaIdsParams
     */
    'mediaIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MediaInfo
 */
export interface MediaInfo {
    /**
     * Hash of the file content, to ensure that the same files don\'t get duplicated
     * @type {string}
     * @memberof MediaInfo
     */
    'contentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof MediaInfo
     */
    'createDate'?: number;
    /**
     * Total time, in milliseconds, of a video
     * @type {number}
     * @memberof MediaInfo
     */
    'duration'?: number;
    /**
     * If the media disabled. This can happen when the backing file(s) are deleted, but the media stays behind because it can be re-used if needed.
     * @type {boolean}
     * @memberof MediaInfo
     */
    'enabled'?: boolean;
    /**
     * Slices of files whos content hash to the contentId
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'fileIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MediaInfo
     */
    'height'?: number;
    /**
     * If the media is hidden from the timeline TODO - make this per user
     * @type {boolean}
     * @memberof MediaInfo
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaInfo
     */
    'imported'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'likedBy'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MediaInfo
     */
    'location'?: Array<number>;
    /**
     * Mime-type key of the media
     * @type {string}
     * @memberof MediaInfo
     */
    'mimeType'?: string;
    /**
     * User who owns the file that resulted in this media being created
     * @type {string}
     * @memberof MediaInfo
     */
    'owner'?: string;
    /**
     * Number of pages (typically 1, 0 in not a valid page count)
     * @type {number}
     * @memberof MediaInfo
     */
    'pageCount'?: number;
    /**
     * Tags from the ML image scan so searching for particular objects in the images can be done
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'recognitionTags'?: Array<string>;
    /**
     * Full-res image dimensions
     * @type {number}
     * @memberof MediaInfo
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface MediaTypeInfo
 */
export interface MediaTypeInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaTypeInfo
     */
    'FileExtension'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MediaTypeInfo
     */
    'FriendlyName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'IsDisplayable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'IsRaw'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'IsVideo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'MultiPage'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaTypeInfo
     */
    'RawThumbExifKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'SupportsImgRecog'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaTypeInfo
     */
    'mime'?: string;
}
/**
 * 
 * @export
 * @interface MediaTypesInfo
 */
export interface MediaTypesInfo {
    /**
     * 
     * @type {{ [key: string]: MediaTypeInfo; }}
     * @memberof MediaTypesInfo
     */
    'extMap'?: { [key: string]: MediaTypeInfo; };
    /**
     * 
     * @type {{ [key: string]: MediaTypeInfo; }}
     * @memberof MediaTypesInfo
     */
    'mimeMap'?: { [key: string]: MediaTypeInfo; };
}
/**
 * 
 * @export
 * @interface MoveFilesParams
 */
export interface MoveFilesParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof MoveFilesParams
     */
    'fileIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MoveFilesParams
     */
    'newParentId'?: string;
}
/**
 * 
 * @export
 * @interface NewFileParams
 */
export interface NewFileParams {
    /**
     * 
     * @type {number}
     * @memberof NewFileParams
     */
    'fileSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NewFileParams
     */
    'isDir'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewFileParams
     */
    'newFileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFileParams
     */
    'parentFolderId'?: string;
}
/**
 * 
 * @export
 * @interface NewFilesInfo
 */
export interface NewFilesInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof NewFilesInfo
     */
    'fileIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NewFilesParams
 */
export interface NewFilesParams {
    /**
     * 
     * @type {Array<NewFileParams>}
     * @memberof NewFilesParams
     */
    'newFiles'?: Array<NewFileParams>;
}
/**
 * 
 * @export
 * @interface NewServerParams
 */
export interface NewServerParams {
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'coreAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'serverId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'usingKey'?: string;
}
/**
 * 
 * @export
 * @interface NewUploadInfo
 */
export interface NewUploadInfo {
    /**
     * 
     * @type {string}
     * @memberof NewUploadInfo
     */
    'uploadId'?: string;
}
/**
 * 
 * @export
 * @interface NewUploadParams
 */
export interface NewUploadParams {
    /**
     * 
     * @type {number}
     * @memberof NewUploadParams
     */
    'chunkSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewUploadParams
     */
    'rootFolderId'?: string;
}
/**
 * 
 * @export
 * @interface NewUserParams
 */
export interface NewUserParams {
    /**
     * 
     * @type {boolean}
     * @memberof NewUserParams
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewUserParams
     */
    'autoActivate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PasswordUpdateParams
 */
export interface PasswordUpdateParams {
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateParams
     */
    'newPassword': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateParams
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface PermissionsInfo
 */
export interface PermissionsInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canView'?: boolean;
}
/**
 * 
 * @export
 * @interface PermissionsParams
 */
export interface PermissionsParams {
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canView'?: boolean;
}
/**
 * 
 * @export
 * @interface RestoreFilesBody
 */
export interface RestoreFilesBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof RestoreFilesBody
     */
    'fileIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RestoreFilesBody
     */
    'newParentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestoreFilesBody
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface RestoreFilesInfo
 */
export interface RestoreFilesInfo {
    /**
     * 
     * @type {string}
     * @memberof RestoreFilesInfo
     */
    'newParentId'?: string;
}
/**
 * 
 * @export
 * @interface ShareInfo
 */
export interface ShareInfo {
    /**
     * 
     * @type {Array<UserInfo>}
     * @memberof ShareInfo
     */
    'accessors'?: Array<UserInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof ShareInfo
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ShareInfo
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShareInfo
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShareInfo
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: PermissionsInfo; }}
     * @memberof ShareInfo
     */
    'permissions'?: { [key: string]: PermissionsInfo; };
    /**
     * 
     * @type {boolean}
     * @memberof ShareInfo
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShareInfo
     */
    'shareId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShareInfo
     */
    'shareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShareInfo
     */
    'shareType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShareInfo
     */
    'timelineOnly'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ShareInfo
     */
    'updated'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShareInfo
     */
    'wormhole'?: boolean;
}
/**
 * 
 * @export
 * @interface StructsInitServerParams
 */
export interface StructsInitServerParams {
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'coreAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'coreKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'fullName'?: string;
    /**
     * For restoring a server, remoind the core of its serverId and api key the remote last used
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'localId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'remoteId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'usingKeyInfo'?: string;
}
/**
 * 
 * @export
 * @interface StructsScanBody
 */
export interface StructsScanBody {
    /**
     * 
     * @type {string}
     * @memberof StructsScanBody
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof StructsScanBody
     */
    'folderId'?: string;
}
/**
 * 
 * @export
 * @interface TakeoutInfo
 */
export interface TakeoutInfo {
    /**
     * 
     * @type {string}
     * @memberof TakeoutInfo
     */
    'filename'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TakeoutInfo
     */
    'single'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TakeoutInfo
     */
    'takeoutId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TakeoutInfo
     */
    'taskId'?: string;
}
/**
 * 
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    'createdBy': string;
    /**
     * 
     * @type {number}
     * @memberof TokenInfo
     */
    'createdTime': number;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof TokenInfo
     */
    'lastUsed': number;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    'remoteUsing': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TowerInfo
 */
export interface TowerInfo {
    /**
     * 
     * @type {number}
     * @memberof TowerInfo
     */
    'backupSize': number;
    /**
     * Address of the remote server, only if the instance is a core. Not set for any remotes/backups on core server, as it IS the core
     * @type {string}
     * @memberof TowerInfo
     */
    'coreAddress': string;
    /**
     * 
     * @type {string}
     * @memberof TowerInfo
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof TowerInfo
     */
    'lastBackup': number;
    /**
     * 
     * @type {string}
     * @memberof TowerInfo
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof TowerInfo
     */
    'online': boolean;
    /**
     * Role the server is currently reporting. This is used to determine if the server is online (and functional) or not
     * @type {string}
     * @memberof TowerInfo
     */
    'reportedRole': string;
    /**
     * Core or Backup
     * @type {string}
     * @memberof TowerInfo
     */
    'role': string;
    /**
     * 
     * @type {boolean}
     * @memberof TowerInfo
     */
    'started': boolean;
    /**
     * 
     * @type {number}
     * @memberof TowerInfo
     */
    'userCount': number;
}
/**
 * 
 * @export
 * @interface UpdateFileParams
 */
export interface UpdateFileParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateFileParams
     */
    'newName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFileParams
     */
    'newParentId'?: string;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'homeId': string;
    /**
     * HomeSize        int64  `json:\"homeSize\" validate:\"required\"`
     * @type {number}
     * @memberof UserInfo
     */
    'permissionLevel': number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'trashId': string;
    /**
     * TrashSize       int64  `json:\"trashSize\" validate:\"required\"`
     * @type {string}
     * @memberof UserInfo
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UserInfoArchive
 */
export interface UserInfoArchive {
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoArchive
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'homeId': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'password'?: string;
    /**
     * HomeSize        int64  `json:\"homeSize\" validate:\"required\"`
     * @type {number}
     * @memberof UserInfoArchive
     */
    'permissionLevel': number;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'trashId': string;
    /**
     * TrashSize       int64  `json:\"trashSize\" validate:\"required\"`
     * @type {string}
     * @memberof UserInfoArchive
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface WeblensErrorInfo
 */
export interface WeblensErrorInfo {
    /**
     * 
     * @type {string}
     * @memberof WeblensErrorInfo
     */
    'error'?: string;
}

/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {ApiKeyParams} params The new token params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (params: ApiKeyParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'params' is not null or undefined
            assertParamExists('createApiKey', 'params', params)
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(params, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} tokenId Api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteApiKey', 'tokenId', tokenId)
            const localVarPath = `/keys/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {ApiKeyParams} params The new token params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(params: ApiKeyParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(params, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} tokenId Api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deleteApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.getApiKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {ApiKeyParams} params The new token params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(params: ApiKeyParams, options?: RawAxiosRequestConfig): AxiosPromise<TokenInfo> {
            return localVarFp.createApiKey(params, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} tokenId Api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApiKey(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenInfo>> {
            return localVarFp.getApiKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * 
     * @summary Create a new api key
     * @param {ApiKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey(params: ApiKeyParams, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).createApiKey(params, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an api key
     * @param {string} tokenId Api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey(tokenId: string, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteApiKey(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public getApiKeys(options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a file to an upload task
         * @param {string} uploadId Upload Id
         * @param {NewFilesParams} request New file params
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilesToUpload: async (uploadId: string, request: NewFilesParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('addFilesToUpload', 'uploadId', uploadId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('addFilesToUpload', 'request', request)
            const localVarPath = `/upload/{uploadId}`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompletePath: async (searchPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchPath' is not null or undefined
            assertParamExists('autocompletePath', 'searchPath', searchPath)
            const localVarPath = `/files/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchPath !== undefined) {
                localVarQueryParameter['searchPath'] = searchPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTakeout: async (request: FilesListParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createTakeout', 'request', request)
            const localVarPath = `/takeout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
         * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('deleteFiles', 'request', request)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ignoreTrash !== undefined) {
                localVarQueryParameter['ignoreTrash'] = ignoreTrash;
            }

            if (preserveFolder !== undefined) {
                localVarQueryParameter['preserveFolder'] = preserveFolder;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {string} [format] File format conversion
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadFile', 'fileId', fileId)
            const localVarPath = `/files/{fileId}/download`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (isTakeout !== undefined) {
                localVarQueryParameter['isTakeout'] = isTakeout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileId: string, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFile', 'fileId', fileId)
            const localVarPath = `/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStats: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileStats', 'fileId', fileId)
            const localVarPath = `/files/{fileId}/stats`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileText: async (fileId: string, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileText', 'fileId', fileId)
            const localVarPath = `/files/{fileId}/text`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the result of an upload task. This will block until the upload is complete
         * @param {string} uploadId Upload Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadResult: async (uploadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('getUploadResult', 'uploadId', uploadId)
            const localVarPath = `/upload/{uploadId}`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles: async (request: MoveFilesParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('moveFiles', 'request', request)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary structsore files from some time in the past
         * @param {RestoreFilesBody} request RestoreFiles files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFiles: async (request: RestoreFilesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('restoreFiles', 'request', request)
            const localVarPath = `/files/structsore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFilename: async (search: string, baseFolderId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchByFilename', 'search', search)
            const localVarPath = `/files/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (baseFolderId !== undefined) {
                localVarQueryParameter['baseFolderId'] = baseFolderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begin a new upload task
         * @param {NewUploadParams} request New upload request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUpload: async (request: NewUploadParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('startUpload', 'request', request)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files out of the trash, structsoring them to where they were before
         * @param {FilesListParams} request Un-trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unTrashFiles: async (request: FilesListParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('unTrashFiles', 'request', request)
            const localVarPath = `/files/untrash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileId File Id
         * @param {UpdateFileParams} request Update file request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (fileId: string, request: UpdateFileParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateFile', 'fileId', fileId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateFile', 'request', request)
            const localVarPath = `/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a chunk to a file upload
         * @param {string} uploadId Upload Id
         * @param {string} fileId File Id
         * @param {File} chunk File chunk
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileChunk: async (uploadId: string, fileId: string, chunk: File, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('uploadFileChunk', 'uploadId', uploadId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('uploadFileChunk', 'fileId', fileId)
            // verify required parameter 'chunk' is not null or undefined
            assertParamExists('uploadFileChunk', 'chunk', chunk)
            const localVarPath = `/upload/{uploadId}/file/{fileId}`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


            if (chunk !== undefined) { 
                localVarFormParams.append('chunk', chunk as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a file to an upload task
         * @param {string} uploadId Upload Id
         * @param {NewFilesParams} request New file params
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFilesToUpload(uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewFilesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFilesToUpload(uploadId, request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.addFilesToUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompletePath(searchPath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.autocompletePath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TakeoutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTakeout(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.createTakeout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
         * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(request, ignoreTrash, preserveFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {string} [format] File format conversion
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileId, shareId, format, isTakeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileId, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileStats(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileStats(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFileStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileText(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileText(fileId, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFileText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedFiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getSharedFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the result of an upload task. This will block until the upload is complete
         * @param {string} uploadId Upload Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadResult(uploadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadResult(uploadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getUploadResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFiles(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.moveFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary structsore files from some time in the past
         * @param {RestoreFilesBody} request RestoreFiles files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreFilesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.restoreFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchByFilename(search, baseFolderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.searchByFilename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Begin a new upload task
         * @param {NewUploadParams} request New upload request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startUpload(request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewUploadInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startUpload(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.startUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files out of the trash, structsoring them to where they were before
         * @param {FilesListParams} request Un-trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unTrashFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.unTrashFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileId File Id
         * @param {UpdateFileParams} request Update file request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(fileId, request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.updateFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a chunk to a file upload
         * @param {string} uploadId Upload Id
         * @param {string} fileId File Id
         * @param {File} chunk File chunk
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileChunk(uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileChunk(uploadId, fileId, chunk, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.uploadFileChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a file to an upload task
         * @param {string} uploadId Upload Id
         * @param {NewFilesParams} request New file params
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilesToUpload(uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewFilesInfo> {
            return localVarFp.addFilesToUpload(uploadId, request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.autocompletePath(searchPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TakeoutInfo> {
            return localVarFp.createTakeout(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
         * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFiles(request, ignoreTrash, preserveFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {string} [format] File format conversion
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadFile(fileId, shareId, format, isTakeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.getFile(fileId, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStats(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFileStats(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileText(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getFileText(fileId, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedFiles(options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.getSharedFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the result of an upload task. This will block until the upload is complete
         * @param {string} uploadId Upload Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadResult(uploadId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getUploadResult(uploadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moveFiles(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary structsore files from some time in the past
         * @param {RestoreFilesBody} request RestoreFiles files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): AxiosPromise<RestoreFilesInfo> {
            return localVarFp.restoreFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileInfo>> {
            return localVarFp.searchByFilename(search, baseFolderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Begin a new upload task
         * @param {NewUploadParams} request New upload request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUpload(request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewUploadInfo> {
            return localVarFp.startUpload(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files out of the trash, structsoring them to where they were before
         * @param {FilesListParams} request Un-trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unTrashFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileId File Id
         * @param {UpdateFileParams} request Update file request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFile(fileId, request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a chunk to a file upload
         * @param {string} uploadId Upload Id
         * @param {string} fileId File Id
         * @param {File} chunk File chunk
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileChunk(uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadFileChunk(uploadId, fileId, chunk, shareId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Add a file to an upload task
     * @param {string} uploadId Upload Id
     * @param {NewFilesParams} request New file params
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public addFilesToUpload(uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).addFilesToUpload(uploadId, request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public autocompletePath(searchPath: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).autocompletePath(searchPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createTakeout(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFiles(request, ignoreTrash, preserveFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {string} [format] File format conversion
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public downloadFile(fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).downloadFile(fileId, shareId, format, isTakeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(fileId, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the statistics of a file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileStats(fileId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileStats(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the text of a text file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileText(fileId: string, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileText(fileId, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getSharedFiles(options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getSharedFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadId Upload Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getUploadResult(uploadId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getUploadResult(uploadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).moveFiles(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).restoreFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).searchByFilename(search, baseFolderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public startUpload(request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).startUpload(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).unTrashFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a File
     * @param {string} fileId File Id
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public updateFile(fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).updateFile(fileId, request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a chunk to a file upload
     * @param {string} uploadId Upload Id
     * @param {string} fileId File Id
     * @param {File} chunk File chunk
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFileChunk(uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadFileChunk(uploadId, fileId, chunk, shareId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FolderApi - axios parameter creator
 * @export
 */
export const FolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (request: CreateFolderBody, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createFolder', 'request', request)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderId Folder Id
         * @param {string} [shareId] Share Id
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: string, shareId?: string, timestamp?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileId File Id
         * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory: async (fileId: string, timestamp: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFolderHistory', 'fileId', fileId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getFolderHistory', 'timestamp', timestamp)
            const localVarPath = `/files/{fileId}/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {StructsScanBody} request Scan parameters
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanFolder: async (request: StructsScanBody, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('scanFolder', 'request', request)
            const localVarPath = `/folder/scan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderId Folder Id
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFolderCover: async (folderId: string, mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('setFolderCover', 'folderId', folderId)
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('setFolderCover', 'mediaId', mediaId)
            const localVarPath = `/folder/{folderId}/cover`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mediaId !== undefined) {
                localVarQueryParameter['mediaId'] = mediaId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderApi - functional programming interface
 * @export
 */
export const FolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderId Folder Id
         * @param {string} [shareId] Share Id
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, shareId, timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileId File Id
         * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileActionInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderHistory(fileId, timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.getFolderHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {StructsScanBody} request Scan parameters
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanFolder(request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanFolder(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.scanFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderId Folder Id
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFolderCover(folderId, mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.setFolderCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FolderApi - factory interface
 * @export
 */
export const FolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.createFolder(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderId Folder Id
         * @param {string} [shareId] Share Id
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.getFolder(folderId, shareId, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileId File Id
         * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileActionInfo>> {
            return localVarFp.getFolderHistory(fileId, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {StructsScanBody} request Scan parameters
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanFolder(request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scanFolder(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderId Folder Id
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setFolderCover(folderId, mediaId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderApi - object-oriented interface
 * @export
 * @class FolderApi
 * @extends {BaseAPI}
 */
export class FolderApi extends BaseAPI {
    /**
     * 
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).createFolder(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a folder
     * @param {string} folderId Folder Id
     * @param {string} [shareId] Share Id
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).getFolder(folderId, shareId, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get actions of a folder at a given time
     * @param {string} fileId File Id
     * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).getFolderHistory(fileId, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispatch a folder scan
     * @param {StructsScanBody} request Scan parameters
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public scanFolder(request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).scanFolder(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the cover image of a folder
     * @param {string} folderId Folder Id
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).setFolderCover(folderId, mediaId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Make sure all media is correctly synced with the file system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupMedia: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/cleanup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Drop all computed media HDIR data. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropHDIRs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/drop/hdirs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropMedia: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/drop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get paginated media
         * @param {MediaBatchParams} request Media Batch Params
         * @param {string} [shareId] File ShareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia: async (request: MediaBatchParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('getMedia', 'request', request)
            const localVarPath = `/media`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get file of media by id
         * @param {string} mediaId Id of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFile: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaFile', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}/file`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaId Media Id
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaImage: async (mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaImage', 'mediaId', mediaId)
            // verify required parameter 'extension' is not null or undefined
            assertParamExists('getMediaImage', 'extension', extension)
            // verify required parameter 'quality' is not null or undefined
            assertParamExists('getMediaImage', 'quality', quality)
            const localVarPath = `/media/{mediaId}.{extension}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)))
                .replace(`{${"extension"}}`, encodeURIComponent(String(extension)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfo: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaInfo', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}/info`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get random media
         * @param {number} count Number of random medias to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomMedia: async (count: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'count' is not null or undefined
            assertParamExists('getRandomMedia', 'count', count)
            const localVarPath = `/media/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like a media
         * @param {string} mediaId Id of media
         * @param {boolean} liked Liked status to set
         * @param {string} [shareId] ShareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaLiked: async (mediaId: string, liked: boolean, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('setMediaLiked', 'mediaId', mediaId)
            // verify required parameter 'liked' is not null or undefined
            assertParamExists('setMediaLiked', 'liked', liked)
            const localVarPath = `/media/{mediaId}/liked`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }

            if (liked !== undefined) {
                localVarQueryParameter['liked'] = liked;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaVisibility: async (hidden: boolean, mediaIds: MediaIdsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hidden' is not null or undefined
            assertParamExists('setMediaVisibility', 'hidden', hidden)
            // verify required parameter 'mediaIds' is not null or undefined
            assertParamExists('setMediaVisibility', 'mediaIds', mediaIds)
            const localVarPath = `/media/visibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream a video
         * @param {string} mediaId Id of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamVideo: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('streamVideo', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}/video`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Make sure all media is correctly synced with the file system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupMedia(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupMedia(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.cleanupMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Drop all computed media HDIR data. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropHDIRs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropHDIRs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.dropHDIRs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropMedia(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropMedia(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.dropMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get paginated media
         * @param {MediaBatchParams} request Media Batch Params
         * @param {string} [shareId] File ShareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMedia(request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMedia(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get file of media by id
         * @param {string} mediaId Id of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaFile(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaFile(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaId Media Id
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaImage(mediaId, extension, quality, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaInfo(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaTypesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get random media
         * @param {number} count Number of random medias to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomMedia(count: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomMedia(count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getRandomMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Like a media
         * @param {string} mediaId Id of media
         * @param {boolean} liked Liked status to set
         * @param {string} [shareId] ShareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMediaLiked(mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMediaLiked(mediaId, liked, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.setMediaLiked']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMediaVisibility(hidden, mediaIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.setMediaVisibility']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stream a video
         * @param {string} mediaId Id of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamVideo(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamVideo(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.streamVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Make sure all media is correctly synced with the file system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupMedia(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cleanupMedia(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Drop all computed media HDIR data. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropHDIRs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dropHDIRs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropMedia(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dropMedia(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get paginated media
         * @param {MediaBatchParams} request Media Batch Params
         * @param {string} [shareId] File ShareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia(request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo> {
            return localVarFp.getMedia(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get file of media by id
         * @param {string} mediaId Id of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFile(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.getMediaFile(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaId Media Id
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getMediaImage(mediaId, extension, quality, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaInfo> {
            return localVarFp.getMediaInfo(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaTypes(options?: RawAxiosRequestConfig): AxiosPromise<MediaTypesInfo> {
            return localVarFp.getMediaTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get random media
         * @param {number} count Number of random medias to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomMedia(count: number, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo> {
            return localVarFp.getRandomMedia(count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Like a media
         * @param {string} mediaId Id of media
         * @param {boolean} liked Liked status to set
         * @param {string} [shareId] ShareId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaLiked(mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMediaLiked(mediaId, liked, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMediaVisibility(hidden, mediaIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stream a video
         * @param {string} mediaId Id of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamVideo(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.streamVideo(mediaId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public cleanupMedia(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).cleanupMedia(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Drop all computed media HDIR data. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public dropHDIRs(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).dropHDIRs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public dropMedia(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).dropMedia(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareId] File ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMedia(request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMedia(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get file of media by id
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaFile(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaFile(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a media image bytes
     * @param {string} mediaId Media Id
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaImage(mediaId, extension, quality, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media info
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaInfo(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaTypes(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getRandomMedia(count: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getRandomMedia(count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Like a media
     * @param {string} mediaId Id of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareId] ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public setMediaLiked(mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).setMediaLiked(mediaId, liked, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).setMediaVisibility(hidden, mediaIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stream a video
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public streamVideo(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).streamVideo(mediaId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetMediaImageQualityEnum = {
    Thumbnail: 'thumbnail',
    Fullres: 'fullres'
} as const;
export type GetMediaImageQualityEnum = typeof GetMediaImageQualityEnum[keyof typeof GetMediaImageQualityEnum];


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a user to a file share
         * @param {string} shareId Share Id
         * @param {AddUserParams} request Share Accessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToShare: async (shareId: string, request: AddUserParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('addUserToShare', 'shareId', shareId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('addUserToShare', 'request', request)
            const localVarPath = `/share/{shareId}/accessors`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share a file
         * @param {FileShareParams} request New File Share Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileShare: async (request: FileShareParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createFileShare', 'request', request)
            const localVarPath = `/share/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileShare: async (shareId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('deleteFileShare', 'shareId', shareId)
            const localVarPath = `/share/{shareId}`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileShare: async (shareId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('getFileShare', 'shareId', shareId)
            const localVarPath = `/share/{shareId}`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user from a file share
         * @param {string} shareId Share Id
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromShare: async (shareId: string, username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('removeUserFromShare', 'shareId', shareId)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('removeUserFromShare', 'username', username)
            const localVarPath = `/share/{shareId}/accessors/{username}`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a share\'s \"public\" status
         * @param {string} shareId Share Id
         * @param {boolean} _public Share Public Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSharePublic: async (shareId: string, _public: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('setSharePublic', 'shareId', shareId)
            // verify required parameter '_public' is not null or undefined
            assertParamExists('setSharePublic', '_public', _public)
            const localVarPath = `/share/{shareId}/public`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a share\'s user permissions
         * @param {string} shareId Share Id
         * @param {string} username Username
         * @param {PermissionsParams} request Share Permissions Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareAccessorPermissions: async (shareId: string, username: string, request: PermissionsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('updateShareAccessorPermissions', 'shareId', shareId)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateShareAccessorPermissions', 'username', username)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateShareAccessorPermissions', 'request', request)
            const localVarPath = `/share/{shareId}/accessors/{username}`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a user to a file share
         * @param {string} shareId Share Id
         * @param {AddUserParams} request Share Accessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToShare(shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToShare(shareId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.addUserToShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Share a file
         * @param {FileShareParams} request New File Share Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileShare(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.createFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileShare(shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.deleteFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileShare(shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.getFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a user from a file share
         * @param {string} shareId Share Id
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromShare(shareId: string, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromShare(shareId, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.removeUserFromShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a share\'s \"public\" status
         * @param {string} shareId Share Id
         * @param {boolean} _public Share Public Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSharePublic(shareId: string, _public: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSharePublic(shareId, _public, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.setSharePublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a share\'s user permissions
         * @param {string} shareId Share Id
         * @param {string} username Username
         * @param {PermissionsParams} request Share Permissions Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareAccessorPermissions(shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareAccessorPermissions(shareId, username, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.updateShareAccessorPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a user to a file share
         * @param {string} shareId Share Id
         * @param {AddUserParams} request Share Accessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToShare(shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.addUserToShare(shareId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share a file
         * @param {FileShareParams} request New File Share Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.createFileShare(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileShare(shareId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFileShare(shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileShare(shareId: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.getFileShare(shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user from a file share
         * @param {string} shareId Share Id
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromShare(shareId: string, username: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.removeUserFromShare(shareId, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a share\'s \"public\" status
         * @param {string} shareId Share Id
         * @param {boolean} _public Share Public Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSharePublic(shareId: string, _public: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSharePublic(shareId, _public, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a share\'s user permissions
         * @param {string} shareId Share Id
         * @param {string} username Username
         * @param {PermissionsParams} request Share Permissions Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareAccessorPermissions(shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.updateShareAccessorPermissions(shareId, username, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Add a user to a file share
     * @param {string} shareId Share Id
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public addUserToShare(shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).addUserToShare(shareId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).createFileShare(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public deleteFileShare(shareId: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).deleteFileShare(shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getFileShare(shareId: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).getFileShare(shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user from a file share
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public removeUserFromShare(shareId: string, username: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).removeUserFromShare(shareId, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a share\'s \"public\" status
     * @param {string} shareId Share Id
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public setSharePublic(shareId: string, _public: boolean, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).setSharePublic(shareId, _public, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a share\'s user permissions
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareAccessorPermissions(shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).updateShareAccessorPermissions(shareId, username, request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TowersApi - axios parameter creator
 * @export
 */
export const TowersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemote: async (request: NewServerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createRemote', 'request', request)
            const localVarPath = `/tower/remote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverId Server Id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemote: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('deleteRemote', 'serverId', serverId)
            const localVarPath = `/tower/{serverId}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} timestamp Timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupInfo: async (timestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBackupInfo', 'timestamp', timestamp)
            const localVarPath = `/tower/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemotes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialize the target server
         * @param {StructsInitServerParams} request Server initialization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeTower: async (request: StructsInitServerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('initializeTower', 'request', request)
            const localVarPath = `/tower/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch backup on a tower
         * @param {string} serverId Server ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchBackup: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('launchBackup', 'serverId', serverId)
            const localVarPath = `/tower/{serverId}/backup`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset tower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTower: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TowersApi - functional programming interface
 * @export
 */
export const TowersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TowersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRemote(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.createRemote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverId Server Id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemote(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRemote(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.deleteRemote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} timestamp Timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupInfo(timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getBackupInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemotes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemotes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getRemotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getServerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initialize the target server
         * @param {StructsInitServerParams} request Server initialization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializeTower(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.initializeTower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Launch backup on a tower
         * @param {string} serverId Server ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async launchBackup(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.launchBackup(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.launchBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset tower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTower(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetTower(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.resetTower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TowersApi - factory interface
 * @export
 */
export const TowersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TowersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo> {
            return localVarFp.createRemote(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverId Server Id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemote(serverId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRemote(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} timestamp Timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<BackupInfo> {
            return localVarFp.getBackupInfo(timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemotes(options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>> {
            return localVarFp.getRemotes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialize the target server
         * @param {StructsInitServerParams} request Server initialization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>> {
            return localVarFp.initializeTower(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Launch backup on a tower
         * @param {string} serverId Server ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchBackup(serverId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.launchBackup(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset tower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTower(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetTower(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TowersApi - object-oriented interface
 * @export
 * @class TowersApi
 * @extends {BaseAPI}
 */
export class TowersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public createRemote(request: NewServerParams, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).createRemote(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a remote
     * @param {string} serverId Server Id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public deleteRemote(serverId: string, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).deleteRemote(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getBackupInfo(timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public getRemotes(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getRemotes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public getServerInfo(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).initializeTower(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Launch backup on a tower
     * @param {string} serverId Server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public launchBackup(serverId: string, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).launchBackup(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    public resetTower(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).resetTower(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target activation status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (username: string, setActive: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activateUser', 'username', username)
            // verify required parameter 'setActive' is not null or undefined
            assertParamExists('activateUser', 'setActive', setActive)
            const localVarPath = `/users/{username}/active`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (setActive !== undefined) {
                localVarQueryParameter['setActive'] = setActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update display name of a user
         * @param {string} username Username of user to update
         * @param {string} newFullName New full name of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDisplayName: async (username: string, newFullName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('changeDisplayName', 'username', username)
            // verify required parameter 'newFullName' is not null or undefined
            assertParamExists('changeDisplayName', 'newFullName', newFullName)
            const localVarPath = `/users/{username}/fullName`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newFullName !== undefined) {
                localVarQueryParameter['newFullName'] = newFullName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if username is already taken
         * @param {string} username Username of user to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExists: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('checkExists', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (newUserParams: NewUserParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newUserParams' is not null or undefined
            assertParamExists('createUser', 'newUserParams', newUserParams)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginParams: LoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('loginUser', 'loginParams', loginParams)
            const localVarPath = `/users/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchUsers', 'search', search)
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAdmin: async (username: string, setAdmin: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('setUserAdmin', 'username', username)
            // verify required parameter 'setAdmin' is not null or undefined
            assertParamExists('setUserAdmin', 'setAdmin', setAdmin)
            const localVarPath = `/users/{username}/admin`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (setAdmin !== undefined) {
                localVarQueryParameter['setAdmin'] = setAdmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (username: string, passwordUpdateParams: PasswordUpdateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserPassword', 'username', username)
            // verify required parameter 'passwordUpdateParams' is not null or undefined
            assertParamExists('updateUserPassword', 'passwordUpdateParams', passwordUpdateParams)
            const localVarPath = `/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target activation status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(username, setActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.activateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update display name of a user
         * @param {string} username Username of user to update
         * @param {string} newFullName New full name of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDisplayName(username, newFullName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeDisplayName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if username is already taken
         * @param {string} username Username of user to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExists(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExists(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(newUserParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoArchive>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserAdmin(username, setAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.setUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(username, passwordUpdateParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target activation status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activateUser(username, setActive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update display name of a user
         * @param {string} username Username of user to update
         * @param {string} newFullName New full name of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeDisplayName(username, newFullName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if username is already taken
         * @param {string} username Username of user to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExists(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkExists(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUser(newUserParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfoArchive>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.loginUser(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(search: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfo>> {
            return localVarFp.searchUsers(search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setUserAdmin(username, setAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPassword(username, passwordUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).activateUser(username, setActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeDisplayName(username, newFullName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkExists(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkExists(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(newUserParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).loginUser(loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(search: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).setUserAdmin(username, setAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(username, passwordUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}



