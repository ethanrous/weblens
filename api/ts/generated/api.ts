/* tslint:disable */
/* eslint-disable */
/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface APIKeyParams {
    'name': string;
}
export interface AddUserParams {
    'canDelete'?: boolean;
    'canDownload'?: boolean;
    'canEdit'?: boolean;
    'canView'?: boolean;
    'username': string;
}
export interface BackupInfo {
    'fileHistory'?: Array<FileActionInfo>;
    'instances'?: Array<TowerInfo>;
    'lifetimesCount'?: number;
    'tokens'?: Array<TokenInfo>;
    'users'?: Array<UserInfoArchive>;
}
export interface Bundle {
    'auth.allow_registrations'?: boolean;
    'media.hdir_processing_enabled'?: boolean;
}
export interface CreateFolderBody {
    'children'?: Array<string>;
    'newFolderName': string;
    'parentFolderID': string;
}
export interface FileActionInfo {
    'actionType': string;
    'contentID'?: string;
    'destinationPath'?: string;
    'eventID': string;
    'fileID': string;
    'filepath'?: string;
    'originPath'?: string;
    'parentID': string;
    'size': number;
    'timestamp': number;
    'towerID': string;
}
export interface FileInfo {
    'childrenIds'?: Array<string>;
    'contentID'?: string;
    'hasRestoreMedia'?: boolean;
    'id'?: string;
    'isDir'?: boolean;
    'modifiable'?: boolean;
    'modifyTimestamp'?: number;
    'owner'?: string;
    'parentID'?: string;
    'pastFile'?: boolean;
    'permissions'?: PermissionsInfo;
    'portablePath'?: string;
    'shareID'?: string;
    'size'?: number;
}
export interface FileShareParams {
    'fileID'?: string;
    'public'?: boolean;
    'timelineOnly'?: boolean;
    'users'?: Array<string>;
    'wormhole'?: boolean;
}
export interface FilesListParams {
    'fileIDs'?: Array<string>;
}
export interface FolderInfo {
    'children'?: Array<FileInfo>;
    'medias'?: Array<MediaInfo>;
    'parents'?: Array<FileInfo>;
    'self'?: FileInfo;
}
export interface FsFilepath {
    'relPath'?: string;
    'rootAlias'?: string;
}
export interface HistoryFileAction {
    'actionType'?: string;
    'contentID'?: string;
    'destinationPath'?: FsFilepath;
    /**
     * The user or system that performed the action
     */
    'doer'?: string;
    'eventID'?: string;
    'fileID'?: string;
    'filepath'?: FsFilepath;
    'id'?: string;
    'originPath'?: FsFilepath;
    'size'?: number;
    'timestamp'?: string;
    'towerID'?: string;
}
export interface LoginBody {
    'password': string;
    'username': string;
}
export interface MediaBatchInfo {
    'Media'?: Array<MediaInfo>;
    'mediaCount'?: number;
    'totalMediaCount'?: number;
}
export interface MediaBatchParams {
    'folderIDs'?: Array<string>;
    'hidden'?: boolean;
    'limit'?: number;
    'mediaIDs'?: Array<string>;
    'page'?: number;
    'raw'?: boolean;
    'search'?: string;
    'sort'?: MediaBatchParamsSortEnum;
    'sortDirection'?: number;
}

export const MediaBatchParamsSortEnum = {
    CreateDate: 'createDate'
} as const;

export type MediaBatchParamsSortEnum = typeof MediaBatchParamsSortEnum[keyof typeof MediaBatchParamsSortEnum];

export interface MediaIDsParams {
    'mediaIDs'?: Array<string>;
}
export interface MediaInfo {
    /**
     * Hash of the file content, to ensure that the same files don\'t get duplicated
     */
    'contentID'?: string;
    'createDate'?: number;
    /**
     * Total time, in milliseconds, of a video
     */
    'duration'?: number;
    /**
     * If the media disabled. This can happen when the backing file(s) are deleted, but the media stays behind because it can be re-used if needed.
     */
    'enabled'?: boolean;
    /**
     * Slices of files whos content hash to the contentId
     */
    'fileIDs'?: Array<string>;
    /**
     * Similarity score from HDIR search
     */
    'hdirScore'?: number;
    'height'?: number;
    /**
     * If the media is hidden from the timeline TODO - make this per user
     */
    'hidden'?: boolean;
    'imported'?: boolean;
    'likedBy'?: Array<string>;
    'location'?: Array<number>;
    /**
     * Mime-type key of the media
     */
    'mimeType'?: string;
    /**
     * User who owns the file that resulted in this media being created
     */
    'owner'?: string;
    /**
     * Number of pages (typically 1, 0 in not a valid page count)
     */
    'pageCount'?: number;
    /**
     * Full-res image dimensions
     */
    'width'?: number;
}
export interface MediaTypeInfo {
    'FileExtension'?: Array<string>;
    'FriendlyName'?: string;
    'IsDisplayable'?: boolean;
    'IsRaw'?: boolean;
    'IsVideo'?: boolean;
    'MultiPage'?: boolean;
    'RawThumbExifKey'?: string;
    'SupportsImgRecog'?: boolean;
    'mime'?: string;
}
export interface MediaTypesInfo {
    'extMap'?: { [key: string]: MediaTypeInfo; };
    'mimeMap'?: { [key: string]: MediaTypeInfo; };
}
export interface MoveFilesParams {
    'fileIDs'?: Array<string>;
    'newParentID'?: string;
}
export interface NewFileParams {
    'fileSize'?: number;
    'isDir'?: boolean;
    'newFileName'?: string;
    'parentFolderID'?: string;
}
export interface NewFilesInfo {
    'fileIDs'?: Array<string>;
}
export interface NewFilesParams {
    'newFiles'?: Array<NewFileParams>;
}
export interface NewServerParams {
    'coreAddress'?: string;
    'name'?: string;
    'role'?: string;
    'serverID'?: string;
    'usingKey'?: string;
}
export interface NewUploadInfo {
    'uploadID'?: string;
}
export interface NewUploadParams {
    'chunkSize'?: number;
    'rootFolderID'?: string;
}
export interface NewUserParams {
    'admin'?: boolean;
    'autoActivate'?: boolean;
    'fullName': string;
    'password': string;
    'username': string;
}
export interface PasswordUpdateParams {
    'newPassword': string;
    'oldPassword'?: string;
}
export interface PermissionsInfo {
    'canDelete'?: boolean;
    'canDownload'?: boolean;
    'canEdit'?: boolean;
    'canView'?: boolean;
}
export interface PermissionsParams {
    'canDelete'?: boolean;
    'canDownload'?: boolean;
    'canEdit'?: boolean;
    'canView'?: boolean;
}
export interface RestoreFilesBody {
    'fileIDs'?: Array<string>;
    'newParentID'?: string;
    'timestamp'?: number;
}
export interface RestoreFilesInfo {
    'newParentID'?: string;
}
export interface ShareInfo {
    'accessors'?: Array<UserInfo>;
    'enabled'?: boolean;
    'expires'?: number;
    'fileID'?: string;
    'owner'?: string;
    'permissions'?: { [key: string]: PermissionsInfo; };
    'public'?: boolean;
    'shareID'?: string;
    'shareName'?: string;
    'shareType'?: string;
    'timelineOnly'?: boolean;
    'updated'?: number;
    'wormhole'?: boolean;
}
export interface StructsInitServerParams {
    'coreAddress'?: string;
    'coreKey'?: string;
    'fullName'?: string;
    /**
     * For restoring a server, remoind the core of its serverID and api key the remote last used
     */
    'localID'?: string;
    'name': string;
    'password': string;
    'remoteID'?: string;
    'role': string;
    'username': string;
    'usingKeyInfo'?: string;
}
export interface StructsSetConfigParam {
    'configKey'?: string;
    'configValue'?: object;
}
export interface TakeoutInfo {
    'filename'?: string;
    'single'?: boolean;
    'takeoutID'?: string;
    'taskID'?: string;
}
export interface TaskInfo {
    'Completed': boolean;
    'jobName': string;
    'progress': number;
    'result'?: object;
    'startTime'?: string;
    'status': string;
    'taskID': string;
    'workerID': number;
}
export interface TokenInfo {
    'createdBy': string;
    'createdTime': number;
    'id': string;
    'lastUsed': number;
    'nickname': string;
    'owner': string;
    'remoteUsing': string;
    'token': string;
}
export interface TowerInfo {
    'backupSize': number;
    /**
     * Address of the remote server, only if the instance is a core. Not set for any remotes/backups on core server, as it IS the core
     */
    'coreAddress': string;
    'id': string;
    'lastBackup': number;
    'logLevel'?: string;
    'name': string;
    'online': boolean;
    /**
     * Role the server is currently reporting. This is used to determine if the server is online (and functional) or not
     */
    'reportedRole': string;
    /**
     * Core or Backup
     */
    'role': string;
    'started': boolean;
    'userCount': number;
}
export interface UpdateFileParams {
    'newName'?: string;
    'newParentID'?: string;
}
export interface UserInfo {
    'activated': boolean;
    'fullName': string;
    'homeID': string;
    'isOnline'?: boolean;
    'permissionLevel': number;
    'token'?: string;
    'trashID': string;
    'updatedAt': number;
    'username': string;
}
export interface UserInfoArchive {
    'activated': boolean;
    'fullName': string;
    'homeID': string;
    'isOnline'?: boolean;
    'password'?: string;
    'permissionLevel': number;
    'token'?: string;
    'trashID': string;
    'updatedAt': number;
    'username': string;
}
export interface WLResponseInfo {
    'message'?: string;
}
export interface WeblensErrorInfo {
    'error'?: string;
}

/**
 * APIKeysApi - axios parameter creator
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {APIKeyParams} params The new token params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPIKey: async (params: APIKeyParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'params' is not null or undefined
            assertParamExists('createAPIKey', 'params', params)
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(params, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} tokenID API key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey: async (tokenID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenID' is not null or undefined
            assertParamExists('deleteAPIKey', 'tokenID', tokenID)
            const localVarPath = `/keys/{tokenID}`
                .replace(`{${"tokenID"}}`, encodeURIComponent(String(tokenID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAPIKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {APIKeyParams} params The new token params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAPIKey(params: APIKeyParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAPIKey(params, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.createAPIKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} tokenID API key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAPIKey(tokenID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAPIKey(tokenID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.deleteAPIKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAPIKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAPIKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.getAPIKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeysApi - factory interface
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {APIKeyParams} params The new token params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPIKey(params: APIKeyParams, options?: RawAxiosRequestConfig): AxiosPromise<TokenInfo> {
            return localVarFp.createAPIKey(params, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} tokenID API key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey(tokenID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAPIKey(tokenID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAPIKeys(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenInfo>> {
            return localVarFp.getAPIKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 */
export class APIKeysApi extends BaseAPI {
    /**
     * 
     * @summary Create a new api key
     * @param {APIKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAPIKey(params: APIKeyParams, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).createAPIKey(params, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an api key
     * @param {string} tokenID API key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAPIKey(tokenID: string, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).deleteAPIKey(tokenID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAPIKeys(options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).getAPIKeys(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeatureFlagsApi - axios parameter creator
 */
export const FeatureFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Feature Flags
         * @param {Array<StructsSetConfigParam>} request Feature Flag Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFlags: async (request: Array<StructsSetConfigParam>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('setFlags', 'request', request)
            const localVarPath = `/flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsApi - functional programming interface
 */
export const FeatureFlagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureFlagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.getFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set Feature Flags
         * @param {Array<StructsSetConfigParam>} request Feature Flag Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFlags(request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFlags(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeatureFlagsApi.setFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeatureFlagsApi - factory interface
 */
export const FeatureFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureFlagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Feature Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlags(options?: RawAxiosRequestConfig): AxiosPromise<Bundle> {
            return localVarFp.getFlags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Feature Flags
         * @param {Array<StructsSetConfigParam>} request Feature Flag Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFlags(request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setFlags(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsApi - object-oriented interface
 */
export class FeatureFlagsApi extends BaseAPI {
    /**
     * 
     * @summary Get Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFlags(options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFlags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Feature Flags
     * @param {Array<StructsSetConfigParam>} request Feature Flag Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setFlags(request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).setFlags(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a file to an upload task
         * @param {string} uploadID Upload ID
         * @param {NewFilesParams} request New file params
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilesToUpload: async (uploadID: string, request: NewFilesParams, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadID' is not null or undefined
            assertParamExists('addFilesToUpload', 'uploadID', uploadID)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('addFilesToUpload', 'request', request)
            const localVarPath = `/upload/{uploadID}`
                .replace(`{${"uploadID"}}`, encodeURIComponent(String(uploadID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompletePath: async (searchPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchPath' is not null or undefined
            assertParamExists('autocompletePath', 'searchPath', searchPath)
            const localVarPath = `/files/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchPath !== undefined) {
                localVarQueryParameter['searchPath'] = searchPath;
            }

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTakeout: async (request: FilesListParams, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createTakeout', 'request', request)
            const localVarPath = `/takeout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
         * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('deleteFiles', 'request', request)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ignoreTrash !== undefined) {
                localVarQueryParameter['ignoreTrash'] = ignoreTrash;
            }

            if (preserveFolder !== undefined) {
                localVarQueryParameter['preserveFolder'] = preserveFolder;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {string} [format] File format conversion
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (fileID: string, shareID?: string, format?: string, isTakeout?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('downloadFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/download`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (isTakeout !== undefined) {
                localVarQueryParameter['isTakeout'] = isTakeout;
            }

            localVarHeaderParameter['Accept'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileID: string, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileID File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStats: async (fileID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileStats', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/stats`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileText: async (fileID: string, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileText', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/text`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Accept'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the result of an upload task. This will block until the upload is complete
         * @param {string} uploadID Upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadResult: async (uploadID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadID' is not null or undefined
            assertParamExists('getUploadResult', 'uploadID', uploadID)
            const localVarPath = `/upload/{uploadID}`
                .replace(`{${"uploadID"}}`, encodeURIComponent(String(uploadID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles: async (request: MoveFilesParams, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('moveFiles', 'request', request)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary structsore files from some time in the past
         * @param {RestoreFilesBody} request RestoreFiles files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFiles: async (request: RestoreFilesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('restoreFiles', 'request', request)
            const localVarPath = `/files/structsore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
         * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
         * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
         * @param {boolean} [recursive] Search recursively
         * @param {boolean} [regex] Whether to treat the search term as a regex pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFilename: async (search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchByFilename', 'search', search)
            const localVarPath = `/files/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (baseFolderID !== undefined) {
                localVarQueryParameter['baseFolderID'] = baseFolderID;
            }

            if (sortProp !== undefined) {
                localVarQueryParameter['sortProp'] = sortProp;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (regex !== undefined) {
                localVarQueryParameter['regex'] = regex;
            }

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begin a new upload task
         * @param {NewUploadParams} request New upload request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUpload: async (request: NewUploadParams, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('startUpload', 'request', request)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files out of the trash, structsoring them to where they were before
         * @param {FilesListParams} request Un-trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unTrashFiles: async (request: FilesListParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('unTrashFiles', 'request', request)
            const localVarPath = `/files/untrash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileID File ID
         * @param {UpdateFileParams} request Update file request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (fileID: string, request: UpdateFileParams, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('updateFile', 'fileID', fileID)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateFile', 'request', request)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a chunk to a file upload
         * @param {string} uploadID Upload ID
         * @param {string} fileID File ID
         * @param {File} chunk File chunk
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileChunk: async (uploadID: string, fileID: string, chunk: File, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadID' is not null or undefined
            assertParamExists('uploadFileChunk', 'uploadID', uploadID)
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('uploadFileChunk', 'fileID', fileID)
            // verify required parameter 'chunk' is not null or undefined
            assertParamExists('uploadFileChunk', 'chunk', chunk)
            const localVarPath = `/upload/{uploadID}/file/{fileID}`
                .replace(`{${"uploadID"}}`, encodeURIComponent(String(uploadID)))
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }


            if (chunk !== undefined) { 
                localVarFormParams.append('chunk', chunk as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a file to an upload task
         * @param {string} uploadID Upload ID
         * @param {NewFilesParams} request New file params
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFilesToUpload(uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewFilesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFilesToUpload(uploadID, request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.addFilesToUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompletePath(searchPath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.autocompletePath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTakeout(request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TakeoutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTakeout(request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.createTakeout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
         * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(request, ignoreTrash, preserveFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {string} [format] File format conversion
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(fileID: string, shareID?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileID, shareID, format, isTakeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileID, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileID File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileStats(fileID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileStats(fileID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFileStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileText(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileText(fileID, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFileText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedFiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getSharedFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the result of an upload task. This will block until the upload is complete
         * @param {string} uploadID Upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadResult(uploadID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadResult(uploadID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getUploadResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFiles(request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFiles(request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.moveFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary structsore files from some time in the past
         * @param {RestoreFilesBody} request RestoreFiles files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreFilesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.restoreFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
         * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
         * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
         * @param {boolean} [recursive] Search recursively
         * @param {boolean} [regex] Whether to treat the search term as a regex pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchByFilename(search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchByFilename(search, baseFolderID, sortProp, sortOrder, recursive, regex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.searchByFilename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Begin a new upload task
         * @param {NewUploadParams} request New upload request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startUpload(request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewUploadInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startUpload(request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.startUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files out of the trash, structsoring them to where they were before
         * @param {FilesListParams} request Un-trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unTrashFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.unTrashFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileID File ID
         * @param {UpdateFileParams} request Update file request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(fileID, request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.updateFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a chunk to a file upload
         * @param {string} uploadID Upload ID
         * @param {string} fileID File ID
         * @param {File} chunk File chunk
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileChunk(uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileChunk(uploadID, fileID, chunk, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.uploadFileChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a file to an upload task
         * @param {string} uploadID Upload ID
         * @param {NewFilesParams} request New file params
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilesToUpload(uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewFilesInfo> {
            return localVarFp.addFilesToUpload(uploadID, request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.autocompletePath(searchPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTakeout(request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<TakeoutInfo> {
            return localVarFp.createTakeout(request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
         * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFiles(request, ignoreTrash, preserveFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {string} [format] File format conversion
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileID: string, shareID?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadFile(fileID, shareID, format, isTakeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.getFile(fileID, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileID File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStats(fileID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFileStats(fileID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileID File ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileText(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getFileText(fileID, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedFiles(options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.getSharedFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the result of an upload task. This will block until the upload is complete
         * @param {string} uploadID Upload ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadResult(uploadID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getUploadResult(uploadID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles(request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moveFiles(request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary structsore files from some time in the past
         * @param {RestoreFilesBody} request RestoreFiles files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): AxiosPromise<RestoreFilesInfo> {
            return localVarFp.restoreFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
         * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
         * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
         * @param {boolean} [recursive] Search recursively
         * @param {boolean} [regex] Whether to treat the search term as a regex pattern
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFilename(search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileInfo>> {
            return localVarFp.searchByFilename(search, baseFolderID, sortProp, sortOrder, recursive, regex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Begin a new upload task
         * @param {NewUploadParams} request New upload request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUpload(request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewUploadInfo> {
            return localVarFp.startUpload(request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files out of the trash, structsoring them to where they were before
         * @param {FilesListParams} request Un-trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unTrashFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileID File ID
         * @param {UpdateFileParams} request Update file request body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFile(fileID, request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a chunk to a file upload
         * @param {string} uploadID Upload ID
         * @param {string} fileID File ID
         * @param {File} chunk File chunk
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileChunk(uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadFileChunk(uploadID, fileID, chunk, shareID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Add a file to an upload task
     * @param {string} uploadID Upload ID
     * @param {NewFilesParams} request New file params
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addFilesToUpload(uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).addFilesToUpload(uploadID, request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public autocompletePath(searchPath: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).autocompletePath(searchPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTakeout(request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createTakeout(request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFiles(request, ignoreTrash, preserveFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {string} [format] File format conversion
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadFile(fileID: string, shareID?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).downloadFile(fileID, shareID, format, isTakeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFile(fileID: string, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(fileID, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the statistics of a file
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFileStats(fileID: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileStats(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the text of a text file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFileText(fileID: string, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileText(fileID, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSharedFiles(options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getSharedFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadID Upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUploadResult(uploadID: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getUploadResult(uploadID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public moveFiles(request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).moveFiles(request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).restoreFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
     * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
     * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
     * @param {boolean} [recursive] Search recursively
     * @param {boolean} [regex] Whether to treat the search term as a regex pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchByFilename(search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).searchByFilename(search, baseFolderID, sortProp, sortOrder, recursive, regex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startUpload(request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).startUpload(request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).unTrashFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a File
     * @param {string} fileID File ID
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFile(fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).updateFile(fileID, request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a chunk to a file upload
     * @param {string} uploadID Upload ID
     * @param {string} fileID File ID
     * @param {File} chunk File chunk
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadFileChunk(uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadFileChunk(uploadID, fileID, chunk, shareID, options).then((request) => request(this.axios, this.basePath));
    }
}

export const SearchByFilenameSortPropEnum = {
    Name: 'name',
    Size: 'size',
    UpdatedAt: 'updatedAt'
} as const;
export type SearchByFilenameSortPropEnum = typeof SearchByFilenameSortPropEnum[keyof typeof SearchByFilenameSortPropEnum];
export const SearchByFilenameSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SearchByFilenameSortOrderEnum = typeof SearchByFilenameSortOrderEnum[keyof typeof SearchByFilenameSortOrderEnum];


/**
 * FolderApi - axios parameter creator
 */
export const FolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (request: CreateFolderBody, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createFolder', 'request', request)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderID Folder ID
         * @param {string} [shareID] Share ID
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
         * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderID' is not null or undefined
            assertParamExists('getFolder', 'folderID', folderID)
            const localVarPath = `/folder/{folderID}`
                .replace(`{${"folderID"}}`, encodeURIComponent(String(folderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (sortProp !== undefined) {
                localVarQueryParameter['sortProp'] = sortProp;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileID File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory: async (fileID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFolderHistory', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/history`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {string} folderID Folder ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanFolder: async (folderID: string, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderID' is not null or undefined
            assertParamExists('scanFolder', 'folderID', folderID)
            const localVarPath = `/folder/{folderID}/scan`
                .replace(`{${"folderID"}}`, encodeURIComponent(String(folderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderID Folder ID
         * @param {string} mediaID Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFolderCover: async (folderID: string, mediaID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderID' is not null or undefined
            assertParamExists('setFolderCover', 'folderID', folderID)
            // verify required parameter 'mediaID' is not null or undefined
            assertParamExists('setFolderCover', 'mediaID', mediaID)
            const localVarPath = `/folder/{folderID}/cover`
                .replace(`{${"folderID"}}`, encodeURIComponent(String(folderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mediaID !== undefined) {
                localVarQueryParameter['mediaID'] = mediaID;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderApi - functional programming interface
 */
export const FolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderID Folder ID
         * @param {string} [shareID] Share ID
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
         * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderID, shareID, timestamp, sortProp, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileID File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderHistory(fileID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileActionInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderHistory(fileID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.getFolderHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {string} folderID Folder ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanFolder(folderID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanFolder(folderID, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.scanFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderID Folder ID
         * @param {string} mediaID Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFolderCover(folderID: string, mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFolderCover(folderID, mediaID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.setFolderCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FolderApi - factory interface
 */
export const FolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.createFolder(request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderID Folder ID
         * @param {string} [shareID] Share ID
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
         * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.getFolder(folderID, shareID, timestamp, sortProp, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileID File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory(fileID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileActionInfo>> {
            return localVarFp.getFolderHistory(fileID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {string} folderID Folder ID
         * @param {string} [shareID] Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanFolder(folderID: string, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskInfo> {
            return localVarFp.scanFolder(folderID, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderID Folder ID
         * @param {string} mediaID Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFolderCover(folderID: string, mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setFolderCover(folderID, mediaID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderApi - object-oriented interface
 */
export class FolderApi extends BaseAPI {
    /**
     * 
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFolder(request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).createFolder(request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a folder
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
     * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFolder(folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).getFolder(folderID, shareID, timestamp, sortProp, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get actions of a folder at a given time
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFolderHistory(fileID: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).getFolderHistory(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispatch a folder scan
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scanFolder(folderID: string, shareID?: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).scanFolder(folderID, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the cover image of a folder
     * @param {string} folderID Folder ID
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setFolderCover(folderID: string, mediaID: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).setFolderCover(folderID, mediaID, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetFolderSortPropEnum = {
    Name: 'name',
    Size: 'size',
    UpdatedAt: 'updatedAt'
} as const;
export type GetFolderSortPropEnum = typeof GetFolderSortPropEnum[keyof typeof GetFolderSortPropEnum];
export const GetFolderSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetFolderSortOrderEnum = typeof GetFolderSortOrderEnum[keyof typeof GetFolderSortOrderEnum];


/**
 * MediaApi - axios parameter creator
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Make sure all media is correctly synced with the file system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupMedia: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/cleanup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Drop all computed media HDIR data. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropHDIRs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/drop/hdirs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
         * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropMedia: async (username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/drop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get paginated media
         * @param {MediaBatchParams} request Media Batch Params
         * @param {string} [shareID] File ShareID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia: async (request: MediaBatchParams, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('getMedia', 'request', request)
            const localVarPath = `/media`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get file of media by id
         * @param {string} mediaID ID of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFile: async (mediaID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaID' is not null or undefined
            assertParamExists('getMediaFile', 'mediaID', mediaID)
            const localVarPath = `/media/{mediaID}/file`
                .replace(`{${"mediaID"}}`, encodeURIComponent(String(mediaID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaID Media ID
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaImage: async (mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaID' is not null or undefined
            assertParamExists('getMediaImage', 'mediaID', mediaID)
            // verify required parameter 'extension' is not null or undefined
            assertParamExists('getMediaImage', 'extension', extension)
            // verify required parameter 'quality' is not null or undefined
            assertParamExists('getMediaImage', 'quality', quality)
            const localVarPath = `/media/{mediaID}.{extension}`
                .replace(`{${"mediaID"}}`, encodeURIComponent(String(mediaID)))
                .replace(`{${"extension"}}`, encodeURIComponent(String(extension)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'image/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaID Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfo: async (mediaID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaID' is not null or undefined
            assertParamExists('getMediaInfo', 'mediaID', mediaID)
            const localVarPath = `/media/{mediaID}/info`
                .replace(`{${"mediaID"}}`, encodeURIComponent(String(mediaID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get random media
         * @param {number} count Number of random medias to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomMedia: async (count: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'count' is not null or undefined
            assertParamExists('getRandomMedia', 'count', count)
            const localVarPath = `/media/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like a media
         * @param {string} mediaID ID of media
         * @param {boolean} liked Liked status to set
         * @param {string} [shareID] ShareID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaLiked: async (mediaID: string, liked: boolean, shareID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaID' is not null or undefined
            assertParamExists('setMediaLiked', 'mediaID', mediaID)
            // verify required parameter 'liked' is not null or undefined
            assertParamExists('setMediaLiked', 'liked', liked)
            const localVarPath = `/media/{mediaID}/liked`
                .replace(`{${"mediaID"}}`, encodeURIComponent(String(mediaID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareID !== undefined) {
                localVarQueryParameter['shareID'] = shareID;
            }

            if (liked !== undefined) {
                localVarQueryParameter['liked'] = liked;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaVisibility: async (hidden: boolean, mediaIDs: MediaIDsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hidden' is not null or undefined
            assertParamExists('setMediaVisibility', 'hidden', hidden)
            // verify required parameter 'mediaIDs' is not null or undefined
            assertParamExists('setMediaVisibility', 'mediaIDs', mediaIDs)
            const localVarPath = `/media/visibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaIDs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream a video
         * @param {string} mediaID ID of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamVideo: async (mediaID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaID' is not null or undefined
            assertParamExists('streamVideo', 'mediaID', mediaID)
            const localVarPath = `/media/{mediaID}/video`
                .replace(`{${"mediaID"}}`, encodeURIComponent(String(mediaID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Make sure all media is correctly synced with the file system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupMedia(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupMedia(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.cleanupMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Drop all computed media HDIR data. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropHDIRs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropHDIRs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.dropHDIRs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
         * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropMedia(username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropMedia(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.dropMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get paginated media
         * @param {MediaBatchParams} request Media Batch Params
         * @param {string} [shareID] File ShareID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMedia(request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMedia(request, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get file of media by id
         * @param {string} mediaID ID of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaFile(mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaFile(mediaID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaID Media ID
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaImage(mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaImage(mediaID, extension, quality, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaID Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfo(mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaInfo(mediaID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaTypesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get random media
         * @param {number} count Number of random medias to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomMedia(count: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomMedia(count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getRandomMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Like a media
         * @param {string} mediaID ID of media
         * @param {boolean} liked Liked status to set
         * @param {string} [shareID] ShareID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMediaLiked(mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMediaLiked(mediaID, liked, shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.setMediaLiked']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMediaVisibility(hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMediaVisibility(hidden, mediaIDs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.setMediaVisibility']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stream a video
         * @param {string} mediaID ID of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamVideo(mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamVideo(mediaID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.streamVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Make sure all media is correctly synced with the file system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupMedia(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cleanupMedia(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Drop all computed media HDIR data. Must be server owner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropHDIRs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dropHDIRs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
         * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropMedia(username?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dropMedia(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get paginated media
         * @param {MediaBatchParams} request Media Batch Params
         * @param {string} [shareID] File ShareID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia(request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo> {
            return localVarFp.getMedia(request, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get file of media by id
         * @param {string} mediaID ID of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFile(mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.getMediaFile(mediaID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaID Media ID
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaImage(mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getMediaImage(mediaID, extension, quality, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaID Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfo(mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaInfo> {
            return localVarFp.getMediaInfo(mediaID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaTypes(options?: RawAxiosRequestConfig): AxiosPromise<MediaTypesInfo> {
            return localVarFp.getMediaTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get random media
         * @param {number} count Number of random medias to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomMedia(count: number, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo> {
            return localVarFp.getRandomMedia(count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Like a media
         * @param {string} mediaID ID of media
         * @param {boolean} liked Liked status to set
         * @param {string} [shareID] ShareID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaLiked(mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMediaLiked(mediaID, liked, shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaVisibility(hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMediaVisibility(hidden, mediaIDs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stream a video
         * @param {string} mediaID ID of media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamVideo(mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.streamVideo(mediaID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cleanupMedia(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).cleanupMedia(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Drop all computed media HDIR data. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dropHDIRs(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).dropHDIRs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dropMedia(username?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).dropMedia(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareID] File ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMedia(request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMedia(request, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get file of media by id
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMediaFile(mediaID: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaFile(mediaID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a media image bytes
     * @param {string} mediaID Media ID
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMediaImage(mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaImage(mediaID, extension, quality, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media info
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMediaInfo(mediaID: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaInfo(mediaID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMediaTypes(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRandomMedia(count: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getRandomMedia(count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Like a media
     * @param {string} mediaID ID of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareID] ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setMediaLiked(mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).setMediaLiked(mediaID, liked, shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setMediaVisibility(hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).setMediaVisibility(hidden, mediaIDs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stream a video
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public streamVideo(mediaID: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).streamVideo(mediaID, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetMediaImageQualityEnum = {
    Thumbnail: 'thumbnail',
    Fullres: 'fullres'
} as const;
export type GetMediaImageQualityEnum = typeof GetMediaImageQualityEnum[keyof typeof GetMediaImageQualityEnum];


/**
 * ShareApi - axios parameter creator
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a user to a file share
         * @param {string} shareID Share ID
         * @param {AddUserParams} request Share Accessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToShare: async (shareID: string, request: AddUserParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareID' is not null or undefined
            assertParamExists('addUserToShare', 'shareID', shareID)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('addUserToShare', 'request', request)
            const localVarPath = `/share/{shareID}/accessors`
                .replace(`{${"shareID"}}`, encodeURIComponent(String(shareID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share a file
         * @param {FileShareParams} request New File Share Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileShare: async (request: FileShareParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createFileShare', 'request', request)
            const localVarPath = `/share/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file share
         * @param {string} shareID Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileShare: async (shareID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareID' is not null or undefined
            assertParamExists('deleteFileShare', 'shareID', shareID)
            const localVarPath = `/share/{shareID}`
                .replace(`{${"shareID"}}`, encodeURIComponent(String(shareID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file share
         * @param {string} shareID Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileShare: async (shareID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareID' is not null or undefined
            assertParamExists('getFileShare', 'shareID', shareID)
            const localVarPath = `/share/{shareID}`
                .replace(`{${"shareID"}}`, encodeURIComponent(String(shareID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user from a file share
         * @param {string} shareID Share ID
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromShare: async (shareID: string, username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareID' is not null or undefined
            assertParamExists('removeUserFromShare', 'shareID', shareID)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('removeUserFromShare', 'username', username)
            const localVarPath = `/share/{shareID}/accessors/{username}`
                .replace(`{${"shareID"}}`, encodeURIComponent(String(shareID)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a share\'s \"public\" status
         * @param {string} shareID Share ID
         * @param {boolean} _public Share Public Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSharePublic: async (shareID: string, _public: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareID' is not null or undefined
            assertParamExists('setSharePublic', 'shareID', shareID)
            // verify required parameter '_public' is not null or undefined
            assertParamExists('setSharePublic', '_public', _public)
            const localVarPath = `/share/{shareID}/public`
                .replace(`{${"shareID"}}`, encodeURIComponent(String(shareID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a share\'s user permissions
         * @param {string} shareID Share ID
         * @param {string} username Username
         * @param {PermissionsParams} request Share Permissions Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareAccessorPermissions: async (shareID: string, username: string, request: PermissionsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareID' is not null or undefined
            assertParamExists('updateShareAccessorPermissions', 'shareID', shareID)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateShareAccessorPermissions', 'username', username)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateShareAccessorPermissions', 'request', request)
            const localVarPath = `/share/{shareID}/accessors/{username}`
                .replace(`{${"shareID"}}`, encodeURIComponent(String(shareID)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a user to a file share
         * @param {string} shareID Share ID
         * @param {AddUserParams} request Share Accessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToShare(shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToShare(shareID, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.addUserToShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Share a file
         * @param {FileShareParams} request New File Share Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileShare(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.createFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a file share
         * @param {string} shareID Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileShare(shareID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileShare(shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.deleteFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a file share
         * @param {string} shareID Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileShare(shareID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileShare(shareID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.getFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a user from a file share
         * @param {string} shareID Share ID
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromShare(shareID: string, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromShare(shareID, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.removeUserFromShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a share\'s \"public\" status
         * @param {string} shareID Share ID
         * @param {boolean} _public Share Public Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSharePublic(shareID: string, _public: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSharePublic(shareID, _public, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.setSharePublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a share\'s user permissions
         * @param {string} shareID Share ID
         * @param {string} username Username
         * @param {PermissionsParams} request Share Permissions Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareAccessorPermissions(shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareAccessorPermissions(shareID, username, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.updateShareAccessorPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShareApi - factory interface
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a user to a file share
         * @param {string} shareID Share ID
         * @param {AddUserParams} request Share Accessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToShare(shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.addUserToShare(shareID, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share a file
         * @param {FileShareParams} request New File Share Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.createFileShare(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file share
         * @param {string} shareID Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileShare(shareID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFileShare(shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file share
         * @param {string} shareID Share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileShare(shareID: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.getFileShare(shareID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user from a file share
         * @param {string} shareID Share ID
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromShare(shareID: string, username: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.removeUserFromShare(shareID, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a share\'s \"public\" status
         * @param {string} shareID Share ID
         * @param {boolean} _public Share Public Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSharePublic(shareID: string, _public: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSharePublic(shareID, _public, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a share\'s user permissions
         * @param {string} shareID Share ID
         * @param {string} username Username
         * @param {PermissionsParams} request Share Permissions Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareAccessorPermissions(shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo> {
            return localVarFp.updateShareAccessorPermissions(shareID, username, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Add a user to a file share
     * @param {string} shareID Share ID
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addUserToShare(shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).addUserToShare(shareID, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).createFileShare(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFileShare(shareID: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).deleteFileShare(shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFileShare(shareID: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).getFileShare(shareID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user from a file share
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeUserFromShare(shareID: string, username: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).removeUserFromShare(shareID, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a share\'s \"public\" status
     * @param {string} shareID Share ID
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setSharePublic(shareID: string, _public: boolean, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).setSharePublic(shareID, _public, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a share\'s user permissions
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateShareAccessorPermissions(shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).updateShareAccessorPermissions(shareID, username, request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TowersApi - axios parameter creator
 */
export const TowersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemote: async (request: NewServerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createRemote', 'request', request)
            const localVarPath = `/tower/remote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverID Server ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemote: async (serverID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverID' is not null or undefined
            assertParamExists('deleteRemote', 'serverID', serverID)
            const localVarPath = `/tower/{serverID}`
                .replace(`{${"serverID"}}`, encodeURIComponent(String(serverID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable trace logging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTraceLogging: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower/trace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Flush Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flushCache: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower/cache`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} timestamp Timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupInfo: async (timestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getBackupInfo', 'timestamp', timestamp)
            const localVarPath = `/tower/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a page of file actions
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedHistoryActions: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemotes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Running Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningTasks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialize the target server
         * @param {StructsInitServerParams} request Server initialization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeTower: async (request: StructsInitServerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('initializeTower', 'request', request)
            const localVarPath = `/tower/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch backup on a tower
         * @param {string} serverID Server ID of the tower to back up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchBackup: async (serverID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverID' is not null or undefined
            assertParamExists('launchBackup', 'serverID', serverID)
            const localVarPath = `/tower/{serverID}/backup`
                .replace(`{${"serverID"}}`, encodeURIComponent(String(serverID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset tower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTower: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tower/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TowersApi - functional programming interface
 */
export const TowersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TowersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRemote(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.createRemote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverID Server ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemote(serverID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRemote(serverID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.deleteRemote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Enable trace logging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTraceLogging(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTraceLogging(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.enableTraceLogging']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Flush Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flushCache(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WLResponseInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flushCache(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.flushCache']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} timestamp Timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupInfo(timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getBackupInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a page of file actions
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPagedHistoryActions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HistoryFileAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPagedHistoryActions(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getPagedHistoryActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemotes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemotes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getRemotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Running Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunningTasks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunningTasks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getRunningTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.getServerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initialize the target server
         * @param {StructsInitServerParams} request Server initialization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializeTower(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.initializeTower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Launch backup on a tower
         * @param {string} serverID Server ID of the tower to back up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async launchBackup(serverID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.launchBackup(serverID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.launchBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset tower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTower(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetTower(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TowersApi.resetTower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TowersApi - factory interface
 */
export const TowersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TowersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo> {
            return localVarFp.createRemote(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverID Server ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemote(serverID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRemote(serverID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable trace logging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTraceLogging(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.enableTraceLogging(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Flush Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flushCache(options?: RawAxiosRequestConfig): AxiosPromise<WLResponseInfo> {
            return localVarFp.flushCache(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} timestamp Timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<BackupInfo> {
            return localVarFp.getBackupInfo(timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a page of file actions
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedHistoryActions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<HistoryFileAction>> {
            return localVarFp.getPagedHistoryActions(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemotes(options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>> {
            return localVarFp.getRemotes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Running Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningTasks(options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskInfo>> {
            return localVarFp.getRunningTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialize the target server
         * @param {StructsInitServerParams} request Server initialization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>> {
            return localVarFp.initializeTower(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Launch backup on a tower
         * @param {string} serverID Server ID of the tower to back up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchBackup(serverID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.launchBackup(serverID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset tower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTower(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetTower(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TowersApi - object-oriented interface
 */
export class TowersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRemote(request: NewServerParams, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).createRemote(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a remote
     * @param {string} serverID Server ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRemote(serverID: string, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).deleteRemote(serverID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable trace logging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableTraceLogging(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).enableTraceLogging(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Flush Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flushCache(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).flushCache(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getBackupInfo(timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a page of file actions
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPagedHistoryActions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getPagedHistoryActions(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRemotes(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getRemotes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Running Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRunningTasks(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getRunningTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServerInfo(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).initializeTower(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Launch backup on a tower
     * @param {string} serverID Server ID of the tower to back up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public launchBackup(serverID: string, options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).launchBackup(serverID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetTower(options?: RawAxiosRequestConfig) {
        return TowersApiFp(this.configuration).resetTower(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target activation status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (username: string, setActive: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activateUser', 'username', username)
            // verify required parameter 'setActive' is not null or undefined
            assertParamExists('activateUser', 'setActive', setActive)
            const localVarPath = `/users/{username}/active`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (setActive !== undefined) {
                localVarQueryParameter['setActive'] = setActive;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update display name of a user
         * @param {string} username Username of user to update
         * @param {string} newFullName New full name of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDisplayName: async (username: string, newFullName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('changeDisplayName', 'username', username)
            // verify required parameter 'newFullName' is not null or undefined
            assertParamExists('changeDisplayName', 'newFullName', newFullName)
            const localVarPath = `/users/{username}/fullName`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newFullName !== undefined) {
                localVarQueryParameter['newFullName'] = newFullName;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if username is already taken
         * @param {string} username Username of user to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExists: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('checkExists', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (newUserParams: NewUserParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newUserParams' is not null or undefined
            assertParamExists('createUser', 'newUserParams', newUserParams)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginParams: LoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('loginUser', 'loginParams', loginParams)
            const localVarPath = `/users/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchUsers', 'search', search)
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAdmin: async (username: string, setAdmin: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('setUserAdmin', 'username', username)
            // verify required parameter 'setAdmin' is not null or undefined
            assertParamExists('setUserAdmin', 'setAdmin', setAdmin)
            const localVarPath = `/users/{username}/admin`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (setAdmin !== undefined) {
                localVarQueryParameter['setAdmin'] = setAdmin;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (username: string, passwordUpdateParams: PasswordUpdateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserPassword', 'username', username)
            // verify required parameter 'passwordUpdateParams' is not null or undefined
            assertParamExists('updateUserPassword', 'passwordUpdateParams', passwordUpdateParams)
            const localVarPath = `/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target activation status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(username, setActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.activateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update display name of a user
         * @param {string} username Username of user to update
         * @param {string} newFullName New full name of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDisplayName(username, newFullName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeDisplayName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if username is already taken
         * @param {string} username Username of user to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExists(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExists(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(newUserParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoArchive>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserAdmin(username, setAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.setUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(username, passwordUpdateParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target activation status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activateUser(username, setActive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update display name of a user
         * @param {string} username Username of user to update
         * @param {string} newFullName New full name of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.changeDisplayName(username, newFullName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if username is already taken
         * @param {string} username Username of user to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExists(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkExists(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUser(newUserParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfoArchive>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.loginUser(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(search: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfo>> {
            return localVarFp.searchUsers(search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setUserAdmin(username, setAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPassword(username, passwordUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).activateUser(username, setActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeDisplayName(username, newFullName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkExists(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkExists(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(newUserParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).loginUser(loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchUsers(search: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).setUserAdmin(username, setAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(username, passwordUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}



