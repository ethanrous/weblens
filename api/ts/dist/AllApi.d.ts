import * as axios from 'axios';
import { RawAxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';

/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs {
    url: string;
    options: RawAxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 *
 * @export
 * @interface AddUserParams
 */
interface AddUserParams {
    /**
     *
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canDelete'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canDownload'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof AddUserParams
     */
    'canEdit'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AddUserParams
     */
    'username': string;
}
/**
 *
 * @export
 * @interface ApiKeyParams
 */
interface ApiKeyParams {
    /**
     *
     * @type {string}
     * @memberof ApiKeyParams
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BackupInfo
 */
interface BackupInfo {
    /**
     *
     * @type {Array<FileActionInfo>}
     * @memberof BackupInfo
     */
    'fileHistory'?: Array<FileActionInfo>;
    /**
     *
     * @type {Array<TowerInfo>}
     * @memberof BackupInfo
     */
    'instances'?: Array<TowerInfo>;
    /**
     *
     * @type {number}
     * @memberof BackupInfo
     */
    'lifetimesCount'?: number;
    /**
     *
     * @type {Array<TokenInfo>}
     * @memberof BackupInfo
     */
    'tokens'?: Array<TokenInfo>;
    /**
     *
     * @type {Array<UserInfoArchive>}
     * @memberof BackupInfo
     */
    'users'?: Array<UserInfoArchive>;
}
/**
 *
 * @export
 * @interface CreateFolderBody
 */
interface CreateFolderBody {
    /**
     *
     * @type {Array<string>}
     * @memberof CreateFolderBody
     */
    'children'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateFolderBody
     */
    'newFolderName': string;
    /**
     *
     * @type {string}
     * @memberof CreateFolderBody
     */
    'parentFolderId': string;
}
/**
 *
 * @export
 * @interface FileActionInfo
 */
interface FileActionInfo {
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'actionType': string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'contentId'?: string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'destinationPath'?: string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'eventId': string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'fileId': string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'filepath'?: string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'originPath'?: string;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'parentId': string;
    /**
     *
     * @type {number}
     * @memberof FileActionInfo
     */
    'size': number;
    /**
     *
     * @type {number}
     * @memberof FileActionInfo
     */
    'timestamp': number;
    /**
     *
     * @type {string}
     * @memberof FileActionInfo
     */
    'towerId': string;
}
/**
 *
 * @export
 * @interface FileInfo
 */
interface FileInfo {
    /**
     *
     * @type {Array<string>}
     * @memberof FileInfo
     */
    'childrenIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'contentId'?: string;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'currentId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof FileInfo
     */
    'hasRestoreMedia'?: boolean;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'id'?: string;
    /**
     *
     * @type {boolean}
     * @memberof FileInfo
     */
    'isDir'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof FileInfo
     */
    'modifiable'?: boolean;
    /**
     *
     * @type {number}
     * @memberof FileInfo
     */
    'modifyTimestamp'?: number;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'owner'?: string;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'parentId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof FileInfo
     */
    'pastFile'?: boolean;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'portablePath'?: string;
    /**
     *
     * @type {string}
     * @memberof FileInfo
     */
    'shareId'?: string;
    /**
     *
     * @type {number}
     * @memberof FileInfo
     */
    'size'?: number;
}
/**
 *
 * @export
 * @interface FileShareParams
 */
interface FileShareParams {
    /**
     *
     * @type {string}
     * @memberof FileShareParams
     */
    'fileId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof FileShareParams
     */
    'public'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof FileShareParams
     */
    'timelineOnly'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof FileShareParams
     */
    'users'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof FileShareParams
     */
    'wormhole'?: boolean;
}
/**
 *
 * @export
 * @interface FilesListParams
 */
interface FilesListParams {
    /**
     *
     * @type {Array<string>}
     * @memberof FilesListParams
     */
    'fileIds'?: Array<string>;
}
/**
 *
 * @export
 * @interface FolderInfo
 */
interface FolderInfo {
    /**
     *
     * @type {Array<FileInfo>}
     * @memberof FolderInfo
     */
    'children'?: Array<FileInfo>;
    /**
     *
     * @type {Array<MediaInfo>}
     * @memberof FolderInfo
     */
    'medias'?: Array<MediaInfo>;
    /**
     *
     * @type {Array<FileInfo>}
     * @memberof FolderInfo
     */
    'parents'?: Array<FileInfo>;
    /**
     *
     * @type {FileInfo}
     * @memberof FolderInfo
     */
    'self'?: FileInfo;
}
/**
 *
 * @export
 * @interface LoginBody
 */
interface LoginBody {
    /**
     *
     * @type {string}
     * @memberof LoginBody
     */
    'password': string;
    /**
     *
     * @type {string}
     * @memberof LoginBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface MediaBatchInfo
 */
interface MediaBatchInfo {
    /**
     *
     * @type {Array<MediaInfo>}
     * @memberof MediaBatchInfo
     */
    'Media'?: Array<MediaInfo>;
    /**
     *
     * @type {number}
     * @memberof MediaBatchInfo
     */
    'mediaCount'?: number;
}
/**
 *
 * @export
 * @interface MediaBatchParams
 */
interface MediaBatchParams {
    /**
     *
     * @type {Array<string>}
     * @memberof MediaBatchParams
     */
    'folderIds'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof MediaBatchParams
     */
    'hidden'?: boolean;
    /**
     *
     * @type {number}
     * @memberof MediaBatchParams
     */
    'limit'?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof MediaBatchParams
     */
    'mediaIds'?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MediaBatchParams
     */
    'page'?: number;
    /**
     *
     * @type {boolean}
     * @memberof MediaBatchParams
     */
    'raw'?: boolean;
    /**
     *
     * @type {string}
     * @memberof MediaBatchParams
     */
    'search'?: string;
    /**
     *
     * @type {string}
     * @memberof MediaBatchParams
     */
    'sort'?: MediaBatchParamsSortEnum;
    /**
     *
     * @type {number}
     * @memberof MediaBatchParams
     */
    'sortDirection'?: number;
}
declare const MediaBatchParamsSortEnum: {
    readonly CreateDate: "createDate";
};
type MediaBatchParamsSortEnum = typeof MediaBatchParamsSortEnum[keyof typeof MediaBatchParamsSortEnum];
/**
 *
 * @export
 * @interface MediaIdsParams
 */
interface MediaIdsParams {
    /**
     *
     * @type {Array<string>}
     * @memberof MediaIdsParams
     */
    'mediaIds'?: Array<string>;
}
/**
 *
 * @export
 * @interface MediaInfo
 */
interface MediaInfo {
    /**
     * Hash of the file content, to ensure that the same files don\'t get duplicated
     * @type {string}
     * @memberof MediaInfo
     */
    'contentId'?: string;
    /**
     *
     * @type {number}
     * @memberof MediaInfo
     */
    'createDate'?: number;
    /**
     * Total time, in milliseconds, of a video
     * @type {number}
     * @memberof MediaInfo
     */
    'duration'?: number;
    /**
     * If the media disabled. This can happen when the backing file(s) are deleted, but the media stays behind because it can be re-used if needed.
     * @type {boolean}
     * @memberof MediaInfo
     */
    'enabled'?: boolean;
    /**
     * Slices of files whos content hash to the contentId
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'fileIds'?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MediaInfo
     */
    'height'?: number;
    /**
     * If the media is hidden from the timeline TODO - make this per user
     * @type {boolean}
     * @memberof MediaInfo
     */
    'hidden'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof MediaInfo
     */
    'imported'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'likedBy'?: Array<string>;
    /**
     *
     * @type {Array<number>}
     * @memberof MediaInfo
     */
    'location'?: Array<number>;
    /**
     * Mime-type key of the media
     * @type {string}
     * @memberof MediaInfo
     */
    'mimeType'?: string;
    /**
     * User who owns the file that resulted in this media being created
     * @type {string}
     * @memberof MediaInfo
     */
    'owner'?: string;
    /**
     * Number of pages (typically 1, 0 in not a valid page count)
     * @type {number}
     * @memberof MediaInfo
     */
    'pageCount'?: number;
    /**
     * Tags from the ML image scan so searching for particular objects in the images can be done
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'recognitionTags'?: Array<string>;
    /**
     * Full-res image dimensions
     * @type {number}
     * @memberof MediaInfo
     */
    'width'?: number;
}
/**
 *
 * @export
 * @interface MediaTypeInfo
 */
interface MediaTypeInfo {
    /**
     *
     * @type {Array<string>}
     * @memberof MediaTypeInfo
     */
    'FileExtension'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MediaTypeInfo
     */
    'FriendlyName'?: string;
    /**
     *
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'IsDisplayable'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'IsRaw'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'IsVideo'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'MultiPage'?: boolean;
    /**
     *
     * @type {string}
     * @memberof MediaTypeInfo
     */
    'RawThumbExifKey'?: string;
    /**
     *
     * @type {boolean}
     * @memberof MediaTypeInfo
     */
    'SupportsImgRecog'?: boolean;
    /**
     *
     * @type {string}
     * @memberof MediaTypeInfo
     */
    'mime'?: string;
}
/**
 *
 * @export
 * @interface MediaTypesInfo
 */
interface MediaTypesInfo {
    /**
     *
     * @type {{ [key: string]: MediaTypeInfo; }}
     * @memberof MediaTypesInfo
     */
    'extMap'?: {
        [key: string]: MediaTypeInfo;
    };
    /**
     *
     * @type {{ [key: string]: MediaTypeInfo; }}
     * @memberof MediaTypesInfo
     */
    'mimeMap'?: {
        [key: string]: MediaTypeInfo;
    };
}
/**
 *
 * @export
 * @interface MoveFilesParams
 */
interface MoveFilesParams {
    /**
     *
     * @type {Array<string>}
     * @memberof MoveFilesParams
     */
    'fileIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MoveFilesParams
     */
    'newParentId'?: string;
}
/**
 *
 * @export
 * @interface NewFileParams
 */
interface NewFileParams {
    /**
     *
     * @type {number}
     * @memberof NewFileParams
     */
    'fileSize'?: number;
    /**
     *
     * @type {boolean}
     * @memberof NewFileParams
     */
    'isDir'?: boolean;
    /**
     *
     * @type {string}
     * @memberof NewFileParams
     */
    'newFileName'?: string;
    /**
     *
     * @type {string}
     * @memberof NewFileParams
     */
    'parentFolderId'?: string;
}
/**
 *
 * @export
 * @interface NewFilesInfo
 */
interface NewFilesInfo {
    /**
     *
     * @type {Array<string>}
     * @memberof NewFilesInfo
     */
    'fileIds'?: Array<string>;
}
/**
 *
 * @export
 * @interface NewFilesParams
 */
interface NewFilesParams {
    /**
     *
     * @type {Array<NewFileParams>}
     * @memberof NewFilesParams
     */
    'newFiles'?: Array<NewFileParams>;
}
/**
 *
 * @export
 * @interface NewServerParams
 */
interface NewServerParams {
    /**
     *
     * @type {string}
     * @memberof NewServerParams
     */
    'coreAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof NewServerParams
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof NewServerParams
     */
    'role'?: string;
    /**
     *
     * @type {string}
     * @memberof NewServerParams
     */
    'serverId'?: string;
    /**
     *
     * @type {string}
     * @memberof NewServerParams
     */
    'usingKey'?: string;
}
/**
 *
 * @export
 * @interface NewUploadInfo
 */
interface NewUploadInfo {
    /**
     *
     * @type {string}
     * @memberof NewUploadInfo
     */
    'uploadId'?: string;
}
/**
 *
 * @export
 * @interface NewUploadParams
 */
interface NewUploadParams {
    /**
     *
     * @type {number}
     * @memberof NewUploadParams
     */
    'chunkSize'?: number;
    /**
     *
     * @type {string}
     * @memberof NewUploadParams
     */
    'rootFolderId'?: string;
}
/**
 *
 * @export
 * @interface NewUserParams
 */
interface NewUserParams {
    /**
     *
     * @type {boolean}
     * @memberof NewUserParams
     */
    'admin'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof NewUserParams
     */
    'autoActivate'?: boolean;
    /**
     *
     * @type {string}
     * @memberof NewUserParams
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof NewUserParams
     */
    'password': string;
    /**
     *
     * @type {string}
     * @memberof NewUserParams
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordUpdateParams
 */
interface PasswordUpdateParams {
    /**
     *
     * @type {string}
     * @memberof PasswordUpdateParams
     */
    'newPassword': string;
    /**
     *
     * @type {string}
     * @memberof PasswordUpdateParams
     */
    'oldPassword'?: string;
}
/**
 *
 * @export
 * @interface PermissionsInfo
 */
interface PermissionsInfo {
    /**
     *
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canDelete'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canDownload'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PermissionsInfo
     */
    'canEdit'?: boolean;
}
/**
 *
 * @export
 * @interface PermissionsParams
 */
interface PermissionsParams {
    /**
     *
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canDelete'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canDownload'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PermissionsParams
     */
    'canEdit'?: boolean;
}
/**
 *
 * @export
 * @interface RestoreFilesBody
 */
interface RestoreFilesBody {
    /**
     *
     * @type {Array<string>}
     * @memberof RestoreFilesBody
     */
    'fileIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof RestoreFilesBody
     */
    'newParentId'?: string;
    /**
     *
     * @type {number}
     * @memberof RestoreFilesBody
     */
    'timestamp'?: number;
}
/**
 *
 * @export
 * @interface RestoreFilesInfo
 */
interface RestoreFilesInfo {
    /**
     *
     * @type {string}
     * @memberof RestoreFilesInfo
     */
    'newParentId'?: string;
}
/**
 *
 * @export
 * @interface ShareInfo
 */
interface ShareInfo {
    /**
     *
     * @type {Array<UserInfo>}
     * @memberof ShareInfo
     */
    'accessors'?: Array<UserInfo>;
    /**
     *
     * @type {boolean}
     * @memberof ShareInfo
     */
    'enabled'?: boolean;
    /**
     *
     * @type {number}
     * @memberof ShareInfo
     */
    'expires'?: number;
    /**
     *
     * @type {string}
     * @memberof ShareInfo
     */
    'fileId'?: string;
    /**
     *
     * @type {string}
     * @memberof ShareInfo
     */
    'owner'?: string;
    /**
     *
     * @type {{ [key: string]: PermissionsInfo; }}
     * @memberof ShareInfo
     */
    'permissions'?: {
        [key: string]: PermissionsInfo;
    };
    /**
     *
     * @type {boolean}
     * @memberof ShareInfo
     */
    'public'?: boolean;
    /**
     *
     * @type {string}
     * @memberof ShareInfo
     */
    'shareId'?: string;
    /**
     *
     * @type {string}
     * @memberof ShareInfo
     */
    'shareName'?: string;
    /**
     *
     * @type {string}
     * @memberof ShareInfo
     */
    'shareType'?: string;
    /**
     *
     * @type {boolean}
     * @memberof ShareInfo
     */
    'timelineOnly'?: boolean;
    /**
     *
     * @type {number}
     * @memberof ShareInfo
     */
    'updated'?: number;
    /**
     *
     * @type {boolean}
     * @memberof ShareInfo
     */
    'wormhole'?: boolean;
}
/**
 *
 * @export
 * @interface StructsInitServerParams
 */
interface StructsInitServerParams {
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'coreAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'coreKey'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'fullName'?: string;
    /**
     * For restoring a server, remoind the core of its serverId and api key the remote last used
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'localId'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'password'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'remoteId'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'role'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'username'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsInitServerParams
     */
    'usingKeyInfo'?: string;
}
/**
 *
 * @export
 * @interface StructsScanBody
 */
interface StructsScanBody {
    /**
     *
     * @type {string}
     * @memberof StructsScanBody
     */
    'filename'?: string;
    /**
     *
     * @type {string}
     * @memberof StructsScanBody
     */
    'folderId'?: string;
}
/**
 *
 * @export
 * @interface TakeoutInfo
 */
interface TakeoutInfo {
    /**
     *
     * @type {string}
     * @memberof TakeoutInfo
     */
    'filename'?: string;
    /**
     *
     * @type {boolean}
     * @memberof TakeoutInfo
     */
    'single'?: boolean;
    /**
     *
     * @type {string}
     * @memberof TakeoutInfo
     */
    'takeoutId'?: string;
    /**
     *
     * @type {string}
     * @memberof TakeoutInfo
     */
    'taskId'?: string;
}
/**
 *
 * @export
 * @interface TokenInfo
 */
interface TokenInfo {
    /**
     *
     * @type {string}
     * @memberof TokenInfo
     */
    'createdBy': string;
    /**
     *
     * @type {number}
     * @memberof TokenInfo
     */
    'createdTime': number;
    /**
     *
     * @type {string}
     * @memberof TokenInfo
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof TokenInfo
     */
    'lastUsed': number;
    /**
     *
     * @type {string}
     * @memberof TokenInfo
     */
    'nickname': string;
    /**
     *
     * @type {string}
     * @memberof TokenInfo
     */
    'owner': string;
    /**
     *
     * @type {string}
     * @memberof TokenInfo
     */
    'remoteUsing': string;
    /**
     *
     * @type {string}
     * @memberof TokenInfo
     */
    'token': string;
}
/**
 *
 * @export
 * @interface TowerInfo
 */
interface TowerInfo {
    /**
     *
     * @type {number}
     * @memberof TowerInfo
     */
    'backupSize': number;
    /**
     * Address of the remote server, only if the instance is a core. Not set for any remotes/backups on core server, as it IS the core
     * @type {string}
     * @memberof TowerInfo
     */
    'coreAddress': string;
    /**
     *
     * @type {string}
     * @memberof TowerInfo
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof TowerInfo
     */
    'lastBackup': number;
    /**
     *
     * @type {string}
     * @memberof TowerInfo
     */
    'name': string;
    /**
     *
     * @type {boolean}
     * @memberof TowerInfo
     */
    'online': boolean;
    /**
     * Role the server is currently reporting. This is used to determine if the server is online (and functional) or not
     * @type {string}
     * @memberof TowerInfo
     */
    'reportedRole': string;
    /**
     * Core or Backup
     * @type {string}
     * @memberof TowerInfo
     */
    'role': string;
    /**
     *
     * @type {boolean}
     * @memberof TowerInfo
     */
    'started': boolean;
    /**
     *
     * @type {number}
     * @memberof TowerInfo
     */
    'userCount': number;
}
/**
 *
 * @export
 * @interface UpdateFileParams
 */
interface UpdateFileParams {
    /**
     *
     * @type {string}
     * @memberof UpdateFileParams
     */
    'newName'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateFileParams
     */
    'newParentId'?: string;
}
/**
 *
 * @export
 * @interface UserInfo
 */
interface UserInfo {
    /**
     *
     * @type {boolean}
     * @memberof UserInfo
     */
    'activated': boolean;
    /**
     *
     * @type {string}
     * @memberof UserInfo
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof UserInfo
     */
    'homeId': string;
    /**
     * HomeSize        int64  `json:\"homeSize\" validate:\"required\"`
     * @type {number}
     * @memberof UserInfo
     */
    'permissionLevel': number;
    /**
     *
     * @type {string}
     * @memberof UserInfo
     */
    'token'?: string;
    /**
     *
     * @type {string}
     * @memberof UserInfo
     */
    'trashId': string;
    /**
     * TrashSize       int64  `json:\"trashSize\" validate:\"required\"`
     * @type {string}
     * @memberof UserInfo
     */
    'username': string;
}
/**
 *
 * @export
 * @interface UserInfoArchive
 */
interface UserInfoArchive {
    /**
     *
     * @type {boolean}
     * @memberof UserInfoArchive
     */
    'activated': boolean;
    /**
     *
     * @type {string}
     * @memberof UserInfoArchive
     */
    'fullName': string;
    /**
     *
     * @type {string}
     * @memberof UserInfoArchive
     */
    'homeId': string;
    /**
     *
     * @type {string}
     * @memberof UserInfoArchive
     */
    'password'?: string;
    /**
     * HomeSize        int64  `json:\"homeSize\" validate:\"required\"`
     * @type {number}
     * @memberof UserInfoArchive
     */
    'permissionLevel': number;
    /**
     *
     * @type {string}
     * @memberof UserInfoArchive
     */
    'token'?: string;
    /**
     *
     * @type {string}
     * @memberof UserInfoArchive
     */
    'trashId': string;
    /**
     * TrashSize       int64  `json:\"trashSize\" validate:\"required\"`
     * @type {string}
     * @memberof UserInfoArchive
     */
    'username': string;
}
/**
 *
 * @export
 * @interface WeblensErrorInfo
 */
interface WeblensErrorInfo {
    /**
     *
     * @type {string}
     * @memberof WeblensErrorInfo
     */
    'error'?: string;
}
/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
declare const ApiKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new api key
     * @param {ApiKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: (params: ApiKeyParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenId Api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: (tokenId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeys: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ApiKeysApi - functional programming interface
 * @export
 */
declare const ApiKeysApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new api key
     * @param {ApiKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(params: ApiKeyParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenId Api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfo>>>;
};
/**
 * ApiKeysApi - factory interface
 * @export
 */
declare const ApiKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new api key
     * @param {ApiKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(params: ApiKeyParams, options?: RawAxiosRequestConfig): AxiosPromise<TokenInfo>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenId Api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeys(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenInfo>>;
};
/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
declare class ApiKeysApi extends BaseAPI {
    /**
     *
     * @summary Create a new api key
     * @param {ApiKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    createApiKey(params: ApiKeyParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TokenInfo, any>>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenId Api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    deleteApiKey(tokenId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    getApiKeys(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TokenInfo[], any>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadId Upload Id
     * @param {NewFilesParams} request New file params
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload: (uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath: (searchPath: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout: (request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles: (request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Download a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {string} [format] File format conversion
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: (fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (fileId: string, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats: (fileId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText: (fileId: string, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadId Upload Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult: (uploadId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles: (request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles: (request: RestoreFilesBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename: (search: string, baseFolderId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload: (request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles: (request: FilesListParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a File
     * @param {string} fileId File Id
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile: (fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadId Upload Id
     * @param {string} fileId File Id
     * @param {File} chunk File chunk
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk: (uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadId Upload Id
     * @param {NewFilesParams} request New file params
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload(uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewFilesInfo>>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TakeoutInfo>>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Download a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {string} [format] File format conversion
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadId Upload Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult(uploadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreFilesInfo>>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload(request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewUploadInfo>>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update a File
     * @param {string} fileId File Id
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadId Upload Id
     * @param {string} fileId File Id
     * @param {File} chunk File chunk
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk(uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadId Upload Id
     * @param {NewFilesParams} request New file params
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload(uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewFilesInfo>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TakeoutInfo>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Download a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {string} [format] File format conversion
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles(options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadId Upload Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult(uploadId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): AxiosPromise<RestoreFilesInfo>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileInfo>>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload(request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewUploadInfo>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update a File
     * @param {string} fileId File Id
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadId Upload Id
     * @param {string} fileId File Id
     * @param {File} chunk File chunk
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk(uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
declare class FilesApi extends BaseAPI {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadId Upload Id
     * @param {NewFilesParams} request New file params
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    addFilesToUpload(uploadId: string, request: NewFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<NewFilesInfo, any>>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FolderInfo, any>>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TakeoutInfo, any>>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Download a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {string} [format] File format conversion
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    downloadFile(fileId: string, shareId?: string, format?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<string, any>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo, any>>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFileStats(fileId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFileText(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<string, any>>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getSharedFiles(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FolderInfo, any>>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadId Upload Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getUploadResult(uploadId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<RestoreFilesInfo, any>>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo[], any>>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    startUpload(request: NewUploadParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<NewUploadInfo, any>>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Update a File
     * @param {string} fileId File Id
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    updateFile(fileId: string, request: UpdateFileParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadId Upload Id
     * @param {string} fileId File Id
     * @param {File} chunk File chunk
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    uploadFileChunk(uploadId: string, fileId: string, chunk: File, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * FolderApi - axios parameter creator
 * @export
 */
declare const FolderApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: (request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderId Folder Id
     * @param {string} [shareId] Share Id
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder: (folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileId File Id
     * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory: (fileId: string, timestamp: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {StructsScanBody} request Scan parameters
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder: (request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderId Folder Id
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover: (folderId: string, mediaId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FolderApi - functional programming interface
 * @export
 */
declare const FolderApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderId Folder Id
     * @param {string} [shareId] Share Id
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileId File Id
     * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileActionInfo>>>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {StructsScanBody} request Scan parameters
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder(request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderId Folder Id
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FolderApi - factory interface
 * @export
 */
declare const FolderApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderId Folder Id
     * @param {string} [shareId] Share Id
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileId File Id
     * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileActionInfo>>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {StructsScanBody} request Scan parameters
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder(request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderId Folder Id
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * FolderApi - object-oriented interface
 * @export
 * @class FolderApi
 * @extends {BaseAPI}
 */
declare class FolderApi extends BaseAPI {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo, any>>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderId Folder Id
     * @param {string} [shareId] Share Id
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FolderInfo, any>>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileId File Id
     * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileActionInfo[], any>>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {StructsScanBody} request Scan parameters
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    scanFolder(request: StructsScanBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderId Folder Id
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * MediaApi - axios parameter creator
 * @export
 */
declare const MediaApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareId] File ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia: (request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile: (mediaId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaId Media Id
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage: (mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo: (mediaId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia: (count: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaId Id of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareId] ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked: (mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility: (hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo: (mediaId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MediaApi - functional programming interface
 * @export
 */
declare const MediaApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareId] File ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia(request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaId Media Id
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaInfo>>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaTypesInfo>>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia(count: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaId Id of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareId] ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked(mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * MediaApi - factory interface
 * @export
 */
declare const MediaApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareId] File ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia(request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaId Media Id
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<string>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaInfo>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes(options?: RawAxiosRequestConfig): AxiosPromise<MediaTypesInfo>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia(count: number, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaId Id of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareId] ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked(mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
declare class MediaApi extends BaseAPI {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    cleanupMedia(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    dropMedia(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareId] File ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    getMedia(request: MediaBatchParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaBatchInfo, any>>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    getMediaFile(mediaId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo, any>>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaId Media Id
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<string, any>>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaInfo, any>>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    getMediaTypes(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaTypesInfo, any>>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    getRandomMedia(count: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaBatchInfo, any>>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaId Id of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareId] ShareId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    setMediaLiked(mediaId: string, liked: boolean, shareId?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaId Id of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    streamVideo(mediaId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * @export
 */
declare const GetMediaImageQualityEnum: {
    readonly Thumbnail: "thumbnail";
    readonly Fullres: "fullres";
};
type GetMediaImageQualityEnum = typeof GetMediaImageQualityEnum[keyof typeof GetMediaImageQualityEnum];
/**
 * ShareApi - axios parameter creator
 * @export
 */
declare const ShareApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareId Share Id
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare: (shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare: (request: FileShareParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare: (shareId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare: (shareId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare: (shareId: string, username: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareId Share Id
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic: (shareId: string, _public: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions: (shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ShareApi - functional programming interface
 * @export
 */
declare const ShareApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareId Share Id
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare(shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare(shareId: string, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareId Share Id
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic(shareId: string, _public: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions(shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
};
/**
 * ShareApi - factory interface
 * @export
 */
declare const ShareApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareId Share Id
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare(shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare(shareId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare(shareId: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare(shareId: string, username: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareId Share Id
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic(shareId: string, _public: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions(shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
};
/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
declare class ShareApi extends BaseAPI {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareId Share Id
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    addUserToShare(shareId: string, request: AddUserParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any>>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any>>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    deleteFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    getFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any>>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    removeUserFromShare(shareId: string, username: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any>>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareId Share Id
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    setSharePublic(shareId: string, _public: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareId Share Id
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    updateShareAccessorPermissions(shareId: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any>>;
}
/**
 * TowersApi - axios parameter creator
 * @export
 */
declare const TowersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote: (request: NewServerParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverId Server Id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote: (serverId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo: (timestamp: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower: (request: StructsInitServerParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverId Server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup: (serverId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TowersApi - functional programming interface
 * @export
 */
declare const TowersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverId Server Id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupInfo>>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverId Server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TowersApi - factory interface
 * @export
 */
declare const TowersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverId Server Id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote(serverId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<BackupInfo>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes(options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverId Server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup(serverId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower(options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * TowersApi - object-oriented interface
 * @export
 * @class TowersApi
 * @extends {BaseAPI}
 */
declare class TowersApi extends BaseAPI {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo, any>>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverId Server Id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    deleteRemote(serverId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<BackupInfo, any>>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    getRemotes(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo[], any>>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    getServerInfo(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo, any>>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo[], any>>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverId Server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    launchBackup(serverId: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TowersApi
     */
    resetTower(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser: (username: string, setActive: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName: (username: string, newFullName: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists: (username: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: (newUserParams: NewUserParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (username: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: (loginParams: LoginBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers: (search: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin: (username: string, setAdmin: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword: (username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoArchive>>>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfo>>>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfoArchive>>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfo>>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
declare class UsersApi extends BaseAPI {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    checkExists(username: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUser(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo, any>>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsers(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfoArchive[], any>>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo, any>>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    logoutUser(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo[], any>>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}

type WLAPI = {
    MediaApi: ReturnType<typeof MediaApiFactory>;
    FilesApi: ReturnType<typeof FilesApiFactory>;
    FoldersApi: ReturnType<typeof FolderApiFactory>;
    TowersApi: ReturnType<typeof TowersApiFactory>;
    SharesApi: ReturnType<typeof ShareApiFactory>;
    UsersApi: ReturnType<typeof UsersApiFactory>;
};
declare function WeblensApiFactory(apiEndpoint: string): WLAPI;

export { type AddUserParams, type ApiKeyParams, ApiKeysApi, ApiKeysApiAxiosParamCreator, ApiKeysApiFactory, ApiKeysApiFp, type BackupInfo, type CreateFolderBody, type FileActionInfo, type FileInfo, type FileShareParams, FilesApi, FilesApiAxiosParamCreator, FilesApiFactory, FilesApiFp, type FilesListParams, FolderApi, FolderApiAxiosParamCreator, FolderApiFactory, FolderApiFp, type FolderInfo, GetMediaImageQualityEnum, type LoginBody, MediaApi, MediaApiAxiosParamCreator, MediaApiFactory, MediaApiFp, type MediaBatchInfo, type MediaBatchParams, MediaBatchParamsSortEnum, type MediaIdsParams, type MediaInfo, type MediaTypeInfo, type MediaTypesInfo, type MoveFilesParams, type NewFileParams, type NewFilesInfo, type NewFilesParams, type NewServerParams, type NewUploadInfo, type NewUploadParams, type NewUserParams, type PasswordUpdateParams, type PermissionsInfo, type PermissionsParams, type RestoreFilesBody, type RestoreFilesInfo, ShareApi, ShareApiAxiosParamCreator, ShareApiFactory, ShareApiFp, type ShareInfo, type StructsInitServerParams, type StructsScanBody, type TakeoutInfo, type TokenInfo, type TowerInfo, TowersApi, TowersApiAxiosParamCreator, TowersApiFactory, TowersApiFp, type UpdateFileParams, type UserInfo, type UserInfoArchive, UsersApi, UsersApiAxiosParamCreator, UsersApiFactory, UsersApiFp, type WLAPI, WeblensApiFactory, type WeblensErrorInfo };
