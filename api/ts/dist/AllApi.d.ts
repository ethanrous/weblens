import * as axios from 'axios';
import { AxiosInstance, RawAxiosRequestConfig, AxiosPromise } from 'axios';

/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface AWSv4Configuration {
    options?: {
        region?: string;
        service?: string;
    };
    credentials?: {
        accessKeyId?: string;
        secretAccessKey?: string;
        sessionToken?: string;
    };
}
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    awsv4?: AWSv4Configuration;
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     */
    username?: string;
    /**
     * parameter for basic security
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * parameter for aws4 signature security
     * @param {Object} AWS4Signature - AWS4 Signature security
     * @param {string} options.region - aws region
     * @param {string} options.service - name of the service.
     * @param {string} credentials.accessKeyId - aws access key id
     * @param {string} credentials.secretAccessKey - aws access key
     * @param {string} credentials.sessionToken - aws session token
     * @memberof Configuration
     */
    awsv4?: AWSv4Configuration;
    /**
     * override base path
     */
    basePath?: string;
    /**
     * override server index
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

interface RequestArgs {
    url: string;
    options: RawAxiosRequestConfig;
}
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

interface APIKeyParams {
    'name': string;
}
interface AddUserParams {
    'canDelete'?: boolean;
    'canDownload'?: boolean;
    'canEdit'?: boolean;
    'canView'?: boolean;
    'username': string;
}
interface BackupInfo {
    'fileHistory'?: Array<FileActionInfo>;
    'instances'?: Array<TowerInfo>;
    'lifetimesCount'?: number;
    'tokens'?: Array<TokenInfo>;
    'users'?: Array<UserInfoArchive>;
}
interface Bundle {
    'auth.allow_registrations'?: boolean;
    'media.hdir_processing_enabled'?: boolean;
}
interface CreateFolderBody {
    'children'?: Array<string>;
    'newFolderName': string;
    'parentFolderID': string;
}
interface FileActionInfo {
    'actionType': string;
    'contentID'?: string;
    'destinationPath'?: string;
    'eventID': string;
    'fileID': string;
    'filepath'?: string;
    'originPath'?: string;
    'parentID': string;
    'size': number;
    'timestamp': number;
    'towerID': string;
}
interface FileInfo {
    'childrenIds'?: Array<string>;
    'contentID'?: string;
    'hasRestoreMedia'?: boolean;
    'id'?: string;
    'isDir'?: boolean;
    'modifiable'?: boolean;
    'modifyTimestamp'?: number;
    'owner'?: string;
    'parentID'?: string;
    'pastFile'?: boolean;
    'permissions'?: PermissionsInfo;
    'portablePath'?: string;
    'shareID'?: string;
    'size'?: number;
}
interface FileShareParams {
    'fileID'?: string;
    'public'?: boolean;
    'timelineOnly'?: boolean;
    'users'?: Array<string>;
    'wormhole'?: boolean;
}
interface FilesListParams {
    'fileIDs'?: Array<string>;
}
interface FolderInfo {
    'children'?: Array<FileInfo>;
    'medias'?: Array<MediaInfo>;
    'parents'?: Array<FileInfo>;
    'self'?: FileInfo;
}
interface FsFilepath {
    'relPath'?: string;
    'rootAlias'?: string;
}
interface HistoryFileAction {
    'actionType'?: string;
    'contentID'?: string;
    'destinationPath'?: FsFilepath;
    /**
     * The user or system that performed the action
     */
    'doer'?: string;
    'eventID'?: string;
    'fileID'?: string;
    'filepath'?: FsFilepath;
    'id'?: string;
    'originPath'?: FsFilepath;
    'size'?: number;
    'timestamp'?: string;
    'towerID'?: string;
}
interface LoginBody {
    'password': string;
    'username': string;
}
interface MediaBatchInfo {
    'Media'?: Array<MediaInfo>;
    'mediaCount'?: number;
    'totalMediaCount'?: number;
}
interface MediaBatchParams {
    'folderIDs'?: Array<string>;
    'hidden'?: boolean;
    'limit'?: number;
    'mediaIDs'?: Array<string>;
    'page'?: number;
    'raw'?: boolean;
    'search'?: string;
    'sort'?: MediaBatchParamsSortEnum;
    'sortDirection'?: number;
}
declare const MediaBatchParamsSortEnum: {
    readonly CreateDate: "createDate";
};
type MediaBatchParamsSortEnum = typeof MediaBatchParamsSortEnum[keyof typeof MediaBatchParamsSortEnum];
interface MediaIDsParams {
    'mediaIDs'?: Array<string>;
}
interface MediaInfo {
    /**
     * Hash of the file content, to ensure that the same files don\'t get duplicated
     */
    'contentID'?: string;
    'createDate'?: number;
    /**
     * Total time, in milliseconds, of a video
     */
    'duration'?: number;
    /**
     * If the media disabled. This can happen when the backing file(s) are deleted, but the media stays behind because it can be re-used if needed.
     */
    'enabled'?: boolean;
    /**
     * Slices of files whos content hash to the contentId
     */
    'fileIDs'?: Array<string>;
    /**
     * Similarity score from HDIR search
     */
    'hdirScore'?: number;
    'height'?: number;
    /**
     * If the media is hidden from the timeline TODO - make this per user
     */
    'hidden'?: boolean;
    'imported'?: boolean;
    'likedBy'?: Array<string>;
    'location'?: Array<number>;
    /**
     * Mime-type key of the media
     */
    'mimeType'?: string;
    /**
     * User who owns the file that resulted in this media being created
     */
    'owner'?: string;
    /**
     * Number of pages (typically 1, 0 in not a valid page count)
     */
    'pageCount'?: number;
    /**
     * Full-res image dimensions
     */
    'width'?: number;
}
interface MediaTypeInfo {
    'FileExtension'?: Array<string>;
    'FriendlyName'?: string;
    'IsDisplayable'?: boolean;
    'IsRaw'?: boolean;
    'IsVideo'?: boolean;
    'MultiPage'?: boolean;
    'RawThumbExifKey'?: string;
    'SupportsImgRecog'?: boolean;
    'mime'?: string;
}
interface MediaTypesInfo {
    'extMap'?: {
        [key: string]: MediaTypeInfo;
    };
    'mimeMap'?: {
        [key: string]: MediaTypeInfo;
    };
}
interface MoveFilesParams {
    'fileIDs'?: Array<string>;
    'newParentID'?: string;
}
interface NewFileParams {
    'fileSize'?: number;
    'isDir'?: boolean;
    'newFileName'?: string;
    'parentFolderID'?: string;
}
interface NewFilesInfo {
    'fileIDs'?: Array<string>;
}
interface NewFilesParams {
    'newFiles'?: Array<NewFileParams>;
}
interface NewServerParams {
    'coreAddress'?: string;
    'name'?: string;
    'role'?: string;
    'serverID'?: string;
    'usingKey'?: string;
}
interface NewUploadInfo {
    'uploadID'?: string;
}
interface NewUploadParams {
    'chunkSize'?: number;
    'rootFolderID'?: string;
}
interface NewUserParams {
    'admin'?: boolean;
    'autoActivate'?: boolean;
    'fullName': string;
    'password': string;
    'username': string;
}
interface PasswordUpdateParams {
    'newPassword': string;
    'oldPassword'?: string;
}
interface PermissionsInfo {
    'canDelete'?: boolean;
    'canDownload'?: boolean;
    'canEdit'?: boolean;
    'canView'?: boolean;
}
interface PermissionsParams {
    'canDelete'?: boolean;
    'canDownload'?: boolean;
    'canEdit'?: boolean;
    'canView'?: boolean;
}
interface RestoreFilesBody {
    'fileIDs'?: Array<string>;
    'newParentID'?: string;
    'timestamp'?: number;
}
interface RestoreFilesInfo {
    'newParentID'?: string;
}
interface ShareInfo {
    'accessors'?: Array<UserInfo>;
    'enabled'?: boolean;
    'expires'?: number;
    'fileID'?: string;
    'owner'?: string;
    'permissions'?: {
        [key: string]: PermissionsInfo;
    };
    'public'?: boolean;
    'shareID'?: string;
    'shareName'?: string;
    'shareType'?: string;
    'timelineOnly'?: boolean;
    'updated'?: number;
    'wormhole'?: boolean;
}
interface StructsInitServerParams {
    'coreAddress'?: string;
    'coreKey'?: string;
    'fullName'?: string;
    /**
     * For restoring a server, remoind the core of its serverID and api key the remote last used
     */
    'localID'?: string;
    'name': string;
    'password': string;
    'remoteID'?: string;
    'role': string;
    'username': string;
    'usingKeyInfo'?: string;
}
interface StructsSetConfigParam {
    'configKey'?: string;
    'configValue'?: object;
}
interface TakeoutInfo {
    'filename'?: string;
    'single'?: boolean;
    'takeoutID'?: string;
    'taskID'?: string;
}
interface TaskInfo {
    'Completed': boolean;
    'jobName': string;
    'progress': number;
    'result'?: object;
    'startTime'?: string;
    'status': string;
    'taskID': string;
    'workerID': number;
}
interface TokenInfo {
    'createdBy': string;
    'createdTime': number;
    'id': string;
    'lastUsed': number;
    'nickname': string;
    'owner': string;
    'remoteUsing': string;
    'token': string;
}
interface TowerHealth {
    'status': TowerHealthStatusEnum;
}
declare const TowerHealthStatusEnum: {
    readonly Healthy: "healthy";
    readonly Unhealthy: "unhealthy";
};
type TowerHealthStatusEnum = typeof TowerHealthStatusEnum[keyof typeof TowerHealthStatusEnum];
interface TowerInfo {
    'backupSize': number;
    /**
     * Address of the remote server, only if the instance is a core. Not set for any remotes/backups on core server, as it IS the core
     */
    'coreAddress': string;
    'id': string;
    'lastBackup': number;
    'logLevel'?: string;
    'name': string;
    'online': boolean;
    /**
     * Role the server is currently reporting. This is used to determine if the server is online (and functional) or not
     */
    'reportedRole': string;
    /**
     * Core or Backup
     */
    'role': string;
    'started': boolean;
    'userCount': number;
}
interface UpdateFileParams {
    'newName'?: string;
    'newParentID'?: string;
}
interface UserInfo {
    'activated': boolean;
    'fullName': string;
    'homeID': string;
    'isOnline'?: boolean;
    'permissionLevel': number;
    'token'?: string;
    'trashID': string;
    'updatedAt': number;
    'username': string;
}
interface UserInfoArchive {
    'activated': boolean;
    'fullName': string;
    'homeID': string;
    'isOnline'?: boolean;
    'password'?: string;
    'permissionLevel': number;
    'token'?: string;
    'trashID': string;
    'updatedAt': number;
    'username': string;
}
interface WLResponseInfo {
    'message'?: string;
}
interface WeblensErrorInfo {
    'error'?: string;
}
/**
 * APIKeysApi - axios parameter creator
 */
declare const APIKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new api key
     * @param {APIKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAPIKey: (params: APIKeyParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenID API key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAPIKey: (tokenID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAPIKeys: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * APIKeysApi - functional programming interface
 */
declare const APIKeysApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new api key
     * @param {APIKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAPIKey(params: APIKeyParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenID API key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAPIKey(tokenID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAPIKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfo>>>;
};
/**
 * APIKeysApi - factory interface
 */
declare const APIKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new api key
     * @param {APIKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAPIKey(params: APIKeyParams, options?: RawAxiosRequestConfig): AxiosPromise<TokenInfo>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenID API key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAPIKey(tokenID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAPIKeys(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenInfo>>;
};
/**
 * APIKeysApi - object-oriented interface
 */
declare class APIKeysApi extends BaseAPI {
    /**
     *
     * @summary Create a new api key
     * @param {APIKeyParams} params The new token params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAPIKey(params: APIKeyParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TokenInfo, any, {}>>;
    /**
     *
     * @summary Delete an api key
     * @param {string} tokenID API key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAPIKey(tokenID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAPIKeys(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TokenInfo[], any, {}>>;
}
/**
 * FeatureFlagsApi - axios parameter creator
 */
declare const FeatureFlagsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Get Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlags: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Set Feature Flags
     * @param {Array<StructsSetConfigParam>} request Feature Flag Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFlags: (request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FeatureFlagsApi - functional programming interface
 */
declare const FeatureFlagsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Get Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>>;
    /**
     *
     * @summary Set Feature Flags
     * @param {Array<StructsSetConfigParam>} request Feature Flag Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFlags(request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FeatureFlagsApi - factory interface
 */
declare const FeatureFlagsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Get Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlags(options?: RawAxiosRequestConfig): AxiosPromise<Bundle>;
    /**
     *
     * @summary Set Feature Flags
     * @param {Array<StructsSetConfigParam>} request Feature Flag Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFlags(request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * FeatureFlagsApi - object-oriented interface
 */
declare class FeatureFlagsApi extends BaseAPI {
    /**
     *
     * @summary Get Feature Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFlags(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<Bundle, any, {}>>;
    /**
     *
     * @summary Set Feature Flags
     * @param {Array<StructsSetConfigParam>} request Feature Flag Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFlags(request: Array<StructsSetConfigParam>, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
}
/**
 * FilesApi - axios parameter creator
 */
declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadID Upload ID
     * @param {NewFilesParams} request New file params
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload: (uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath: (searchPath: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Clear all cached zip files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearZipCache: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout: (request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles: (request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Download a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {string} [format] File format conversion
     * @param {number} [quality] JPEG quality (1-100)
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: (fileID: string, shareID?: string, format?: string, quality?: number, isTakeout?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (fileID: string, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats: (fileID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText: (fileID: string, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadID Upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult: (uploadID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles: (request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles: (request: RestoreFilesBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
     * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
     * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
     * @param {boolean} [recursive] Search recursively
     * @param {boolean} [regex] Whether to treat the search term as a regex pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename: (search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload: (request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles: (request: FilesListParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a File
     * @param {string} fileID File ID
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile: (fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadID Upload ID
     * @param {string} fileID File ID
     * @param {File} chunk File chunk
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk: (uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 */
declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadID Upload ID
     * @param {NewFilesParams} request New file params
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload(uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewFilesInfo>>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>>;
    /**
     *
     * @summary Clear all cached zip files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearZipCache(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout(request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TakeoutInfo>>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Download a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {string} [format] File format conversion
     * @param {number} [quality] JPEG quality (1-100)
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(fileID: string, shareID?: string, format?: string, quality?: number, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats(fileID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadID Upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult(uploadID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles(request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreFilesInfo>>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
     * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
     * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
     * @param {boolean} [recursive] Search recursively
     * @param {boolean} [regex] Whether to treat the search term as a regex pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename(search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload(request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewUploadInfo>>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update a File
     * @param {string} fileID File ID
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadID Upload ID
     * @param {string} fileID File ID
     * @param {File} chunk File chunk
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk(uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FilesApi - factory interface
 */
declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadID Upload ID
     * @param {NewFilesParams} request New file params
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload(uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewFilesInfo>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo>;
    /**
     *
     * @summary Clear all cached zip files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearZipCache(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout(request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<TakeoutInfo>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Download a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {string} [format] File format conversion
     * @param {number} [quality] JPEG quality (1-100)
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(fileID: string, shareID?: string, format?: string, quality?: number, isTakeout?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats(fileID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles(options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadID Upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult(uploadID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles(request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): AxiosPromise<RestoreFilesInfo>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
     * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
     * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
     * @param {boolean} [recursive] Search recursively
     * @param {boolean} [regex] Whether to treat the search term as a regex pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename(search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileInfo>>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload(request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<NewUploadInfo>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update a File
     * @param {string} fileID File ID
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadID Upload ID
     * @param {string} fileID File ID
     * @param {File} chunk File chunk
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk(uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * FilesApi - object-oriented interface
 */
declare class FilesApi extends BaseAPI {
    /**
     *
     * @summary Add a file to an upload task
     * @param {string} uploadID Upload ID
     * @param {NewFilesParams} request New file params
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFilesToUpload(uploadID: string, request: NewFilesParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<NewFilesInfo, any, {}>>;
    /**
     *
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FolderInfo, any, {}>>;
    /**
     *
     * @summary Clear all cached zip files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearZipCache(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTakeout(request: FilesListParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TakeoutInfo, any, {}>>;
    /**
     *
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {boolean} [ignoreTrash] Delete files even if they are not in the trash
     * @param {boolean} [preserveFolder] Preserve parent folder if it is empty after deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles(request: FilesListParams, ignoreTrash?: boolean, preserveFolder?: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Download a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {string} [format] File format conversion
     * @param {number} [quality] JPEG quality (1-100)
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(fileID: string, shareID?: string, format?: string, quality?: number, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<string, any, {}>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo, any, {}>>;
    /**
     *
     * @summary Get the statistics of a file
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileStats(fileID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Get the text of a text file
     * @param {string} fileID File ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileText(fileID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<string, any, {}>>;
    /**
     *
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharedFiles(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FolderInfo, any, {}>>;
    /**
     *
     * @summary Get the result of an upload task. This will block until the upload is complete
     * @param {string} uploadID Upload ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadResult(uploadID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveFiles(request: MoveFilesParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary structsore files from some time in the past
     * @param {RestoreFilesBody} request RestoreFiles files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<RestoreFilesInfo, any, {}>>;
    /**
     *
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderID] The folder to search in, defaults to the user\&#39;s home folder
     * @param {SearchByFilenameSortPropEnum} [sortProp] Property to sort by
     * @param {SearchByFilenameSortOrderEnum} [sortOrder] Sort order
     * @param {boolean} [recursive] Search recursively
     * @param {boolean} [regex] Whether to treat the search term as a regex pattern
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByFilename(search: string, baseFolderID?: string, sortProp?: SearchByFilenameSortPropEnum, sortOrder?: SearchByFilenameSortOrderEnum, recursive?: boolean, regex?: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo[], any, {}>>;
    /**
     *
     * @summary Begin a new upload task
     * @param {NewUploadParams} request New upload request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startUpload(request: NewUploadParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<NewUploadInfo, any, {}>>;
    /**
     *
     * @summary Move a list of files out of the trash, structsoring them to where they were before
     * @param {FilesListParams} request Un-trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Update a File
     * @param {string} fileID File ID
     * @param {UpdateFileParams} request Update file request body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(fileID: string, request: UpdateFileParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Add a chunk to a file upload
     * @param {string} uploadID Upload ID
     * @param {string} fileID File ID
     * @param {File} chunk File chunk
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFileChunk(uploadID: string, fileID: string, chunk: File, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
}
declare const SearchByFilenameSortPropEnum: {
    readonly Name: "name";
    readonly Size: "size";
    readonly UpdatedAt: "updatedAt";
};
type SearchByFilenameSortPropEnum = typeof SearchByFilenameSortPropEnum[keyof typeof SearchByFilenameSortPropEnum];
declare const SearchByFilenameSortOrderEnum: {
    readonly Asc: "asc";
    readonly Desc: "desc";
};
type SearchByFilenameSortOrderEnum = typeof SearchByFilenameSortOrderEnum[keyof typeof SearchByFilenameSortOrderEnum];
/**
 * FolderApi - axios parameter creator
 */
declare const FolderApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: (request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
     * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder: (folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory: (fileID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder: (folderID: string, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderID Folder ID
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover: (folderID: string, mediaID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FolderApi - functional programming interface
 */
declare const FolderApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
     * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder(folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory(fileID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileActionInfo>>>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder(folderID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfo>>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderID Folder ID
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover(folderID: string, mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FolderApi - factory interface
 */
declare const FolderApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
     * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder(folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory(fileID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileActionInfo>>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder(folderID: string, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskInfo>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderID Folder ID
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover(folderID: string, mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * FolderApi - object-oriented interface
 */
declare class FolderApi extends BaseAPI {
    /**
     *
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(request: CreateFolderBody, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo, any, {}>>;
    /**
     *
     * @summary Get a folder
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {GetFolderSortPropEnum} [sortProp] Property to sort by
     * @param {GetFolderSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder(folderID: string, shareID?: string, timestamp?: number, sortProp?: GetFolderSortPropEnum, sortOrder?: GetFolderSortOrderEnum, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FolderInfo, any, {}>>;
    /**
     *
     * @summary Get actions of a folder at a given time
     * @param {string} fileID File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolderHistory(fileID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileActionInfo[], any, {}>>;
    /**
     *
     * @summary Dispatch a folder scan
     * @param {string} folderID Folder ID
     * @param {string} [shareID] Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanFolder(folderID: string, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TaskInfo, any, {}>>;
    /**
     *
     * @summary Set the cover image of a folder
     * @param {string} folderID Folder ID
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFolderCover(folderID: string, mediaID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
}
declare const GetFolderSortPropEnum: {
    readonly Name: "name";
    readonly Size: "size";
    readonly UpdatedAt: "updatedAt";
};
type GetFolderSortPropEnum = typeof GetFolderSortPropEnum[keyof typeof GetFolderSortPropEnum];
declare const GetFolderSortOrderEnum: {
    readonly Asc: "asc";
    readonly Desc: "desc";
};
type GetFolderSortOrderEnum = typeof GetFolderSortOrderEnum[keyof typeof GetFolderSortOrderEnum];
/**
 * MediaApi - axios parameter creator
 */
declare const MediaApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Drop all computed media HDIR data. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropHDIRs: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia: (username?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareID] File ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia: (request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile: (mediaID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaID Media ID
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage: (mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo: (mediaID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia: (count: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaID ID of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareID] ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked: (mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility: (hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo: (mediaID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MediaApi - functional programming interface
 */
declare const MediaApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Drop all computed media HDIR data. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropHDIRs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia(username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareID] File ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia(request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile(mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaID Media ID
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage(mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo(mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaInfo>>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaTypesInfo>>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia(count: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaID ID of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareID] ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked(mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility(hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo(mediaID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * MediaApi - factory interface
 */
declare const MediaApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Drop all computed media HDIR data. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropHDIRs(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia(username?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareID] File ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia(request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile(mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaID Media ID
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage(mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<string>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo(mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaInfo>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes(options?: RawAxiosRequestConfig): AxiosPromise<MediaTypesInfo>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia(count: number, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaID ID of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareID] ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked(mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility(hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo(mediaID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * MediaApi - object-oriented interface
 */
declare class MediaApi extends BaseAPI {
    /**
     *
     * @summary Make sure all media is correctly synced with the file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanupMedia(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Drop all computed media HDIR data. Must be server owner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropHDIRs(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary DANGEROUS. Drop all computed media and clear thumbnail in-memory and filesystem cache. Must be server owner.
     * @param {string} [username] Username of owner whose media to drop. If empty, drops all media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dropMedia(username?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Get paginated media
     * @param {MediaBatchParams} request Media Batch Params
     * @param {string} [shareID] File ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMedia(request: MediaBatchParams, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaBatchInfo, any, {}>>;
    /**
     *
     * @summary Get file of media by id
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaFile(mediaID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<FileInfo, any, {}>>;
    /**
     *
     * @summary Get a media image bytes
     * @param {string} mediaID Media ID
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaImage(mediaID: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<string, any, {}>>;
    /**
     *
     * @summary Get media info
     * @param {string} mediaID Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaInfo(mediaID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaInfo, any, {}>>;
    /**
     *
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMediaTypes(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaTypesInfo, any, {}>>;
    /**
     *
     * @summary Get random media
     * @param {number} count Number of random medias to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRandomMedia(count: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<MediaBatchInfo, any, {}>>;
    /**
     *
     * @summary Like a media
     * @param {string} mediaID ID of media
     * @param {boolean} liked Liked status to set
     * @param {string} [shareID] ShareID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaLiked(mediaID: string, liked: boolean, shareID?: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIDsParams} mediaIDs MediaIDs to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMediaVisibility(hidden: boolean, mediaIDs: MediaIDsParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Stream a video
     * @param {string} mediaID ID of media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    streamVideo(mediaID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
}
declare const GetMediaImageQualityEnum: {
    readonly Thumbnail: "thumbnail";
    readonly Fullres: "fullres";
};
type GetMediaImageQualityEnum = typeof GetMediaImageQualityEnum[keyof typeof GetMediaImageQualityEnum];
/**
 * ShareApi - axios parameter creator
 */
declare const ShareApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareID Share ID
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare: (shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare: (request: FileShareParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare: (shareID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare: (shareID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare: (shareID: string, username: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareID Share ID
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic: (shareID: string, _public: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions: (shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ShareApi - functional programming interface
 */
declare const ShareApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareID Share ID
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare(shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare(shareID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare(shareID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare(shareID: string, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareID Share ID
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic(shareID: string, _public: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions(shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareInfo>>;
};
/**
 * ShareApi - factory interface
 */
declare const ShareApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareID Share ID
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare(shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare(shareID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare(shareID: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare(shareID: string, username: string, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareID Share ID
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic(shareID: string, _public: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions(shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): AxiosPromise<ShareInfo>;
};
/**
 * ShareApi - object-oriented interface
 */
declare class ShareApi extends BaseAPI {
    /**
     *
     * @summary Add a user to a file share
     * @param {string} shareID Share ID
     * @param {AddUserParams} request Share Accessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToShare(shareID: string, request: AddUserParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any, {}>>;
    /**
     *
     * @summary Share a file
     * @param {FileShareParams} request New File Share Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileShare(request: FileShareParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any, {}>>;
    /**
     *
     * @summary Delete a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileShare(shareID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Get a file share
     * @param {string} shareID Share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileShare(shareID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any, {}>>;
    /**
     *
     * @summary Remove a user from a file share
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromShare(shareID: string, username: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any, {}>>;
    /**
     *
     * @summary Update a share\'s \"public\" status
     * @param {string} shareID Share ID
     * @param {boolean} _public Share Public Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setSharePublic(shareID: string, _public: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Update a share\'s user permissions
     * @param {string} shareID Share ID
     * @param {string} username Username
     * @param {PermissionsParams} request Share Permissions Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShareAccessorPermissions(shareID: string, username: string, request: PermissionsParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<ShareInfo, any, {}>>;
}
/**
 * TowersApi - axios parameter creator
 */
declare const TowersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote: (request: NewServerParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverID Server ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote: (serverID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Enable trace logging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTraceLogging: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Flush Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flushCache: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo: (timestamp: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a page of file actions
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPagedHistoryActions: (page?: number, pageSize?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get Running Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRunningTasks: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get server health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerHealthStatus: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower: (request: StructsInitServerParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverID Server ID of the tower to back up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup: (serverID: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TowersApi - functional programming interface
 */
declare const TowersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverID Server ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote(serverID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Enable trace logging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTraceLogging(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Flush Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flushCache(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WLResponseInfo>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupInfo>>;
    /**
     *
     * @summary Get a page of file actions
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPagedHistoryActions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HistoryFileAction>>>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>>;
    /**
     *
     * @summary Get Running Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRunningTasks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskInfo>>>;
    /**
     *
     * @summary Get server health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerHealthStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerHealth>>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TowerInfo>>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TowerInfo>>>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverID Server ID of the tower to back up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup(serverID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TowersApi - factory interface
 */
declare const TowersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverID Server ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote(serverID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Enable trace logging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTraceLogging(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Flush Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flushCache(options?: RawAxiosRequestConfig): AxiosPromise<WLResponseInfo>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<BackupInfo>;
    /**
     *
     * @summary Get a page of file actions
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPagedHistoryActions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<HistoryFileAction>>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes(options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>>;
    /**
     *
     * @summary Get Running Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRunningTasks(options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskInfo>>;
    /**
     *
     * @summary Get server health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerHealthStatus(options?: RawAxiosRequestConfig): AxiosPromise<TowerHealth>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(options?: RawAxiosRequestConfig): AxiosPromise<TowerInfo>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): AxiosPromise<Array<TowerInfo>>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverID Server ID of the tower to back up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup(serverID: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower(options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * TowersApi - object-oriented interface
 */
declare class TowersApi extends BaseAPI {
    /**
     *
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo, any, {}>>;
    /**
     *
     * @summary Delete a remote
     * @param {string} serverID Server ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRemote(serverID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Enable trace logging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableTraceLogging(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Flush Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    flushCache(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<WLResponseInfo, any, {}>>;
    /**
     *
     * @summary Get information about a file
     * @param {string} timestamp Timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupInfo(timestamp: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<BackupInfo, any, {}>>;
    /**
     *
     * @summary Get a page of file actions
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPagedHistoryActions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<HistoryFileAction[], any, {}>>;
    /**
     *
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRemotes(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo[], any, {}>>;
    /**
     *
     * @summary Get Running Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRunningTasks(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TaskInfo[], any, {}>>;
    /**
     *
     * @summary Get server health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerHealthStatus(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerHealth, any, {}>>;
    /**
     *
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo, any, {}>>;
    /**
     *
     * @summary Initialize the target server
     * @param {StructsInitServerParams} request Server initialization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeTower(request: StructsInitServerParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<TowerInfo[], any, {}>>;
    /**
     *
     * @summary Launch backup on a tower
     * @param {string} serverID Server ID of the tower to back up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    launchBackup(serverID: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Reset tower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetTower(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
}
/**
 * UsersApi - axios parameter creator
 */
declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser: (username: string, setActive: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName: (username: string, newFullName: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists: (username: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: (newUserParams: NewUserParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (username: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: (loginParams: LoginBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers: (search: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin: (username: string, setAdmin: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword: (username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 */
declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoArchive>>>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfo>>>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UsersApi - factory interface
 */
declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfoArchive>>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfo>>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * UsersApi - object-oriented interface
 */
declare class UsersApi extends BaseAPI {
    /**
     *
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target activation status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Update display name of a user
     * @param {string} username Username of user to update
     * @param {string} newFullName New full name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayName(username: string, newFullName: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo, any, {}>>;
    /**
     *
     * @summary Check if username is already taken
     * @param {string} username Username of user to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkExists(username: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo, any, {}>>;
    /**
     *
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfoArchive[], any, {}>>;
    /**
     *
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo, any, {}>>;
    /**
     *
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<UserInfo[], any, {}>>;
    /**
     *
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
    /**
     *
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<axios.AxiosResponse<void, any, {}>>;
}

type WLAPI = {
    MediaAPI: ReturnType<typeof MediaApiFactory>;
    FilesAPI: ReturnType<typeof FilesApiFactory>;
    FoldersAPI: ReturnType<typeof FolderApiFactory>;
    TowersAPI: ReturnType<typeof TowersApiFactory>;
    SharesAPI: ReturnType<typeof ShareApiFactory>;
    UsersAPI: ReturnType<typeof UsersApiFactory>;
    APIKeysAPI: ReturnType<typeof APIKeysApiFactory>;
    FeatureFlagsAPI: ReturnType<typeof FeatureFlagsApiFactory>;
};
declare function WeblensAPIFactory(apiEndpoint: string): WLAPI;

export { type APIKeyParams, APIKeysApi, APIKeysApiAxiosParamCreator, APIKeysApiFactory, APIKeysApiFp, type AddUserParams, type BackupInfo, type Bundle, type CreateFolderBody, FeatureFlagsApi, FeatureFlagsApiAxiosParamCreator, FeatureFlagsApiFactory, FeatureFlagsApiFp, type FileActionInfo, type FileInfo, type FileShareParams, FilesApi, FilesApiAxiosParamCreator, FilesApiFactory, FilesApiFp, type FilesListParams, FolderApi, FolderApiAxiosParamCreator, FolderApiFactory, FolderApiFp, type FolderInfo, type FsFilepath, GetFolderSortOrderEnum, GetFolderSortPropEnum, GetMediaImageQualityEnum, type HistoryFileAction, type LoginBody, MediaApi, MediaApiAxiosParamCreator, MediaApiFactory, MediaApiFp, type MediaBatchInfo, type MediaBatchParams, MediaBatchParamsSortEnum, type MediaIDsParams, type MediaInfo, type MediaTypeInfo, type MediaTypesInfo, type MoveFilesParams, type NewFileParams, type NewFilesInfo, type NewFilesParams, type NewServerParams, type NewUploadInfo, type NewUploadParams, type NewUserParams, type PasswordUpdateParams, type PermissionsInfo, type PermissionsParams, type RestoreFilesBody, type RestoreFilesInfo, SearchByFilenameSortOrderEnum, SearchByFilenameSortPropEnum, ShareApi, ShareApiAxiosParamCreator, ShareApiFactory, ShareApiFp, type ShareInfo, type StructsInitServerParams, type StructsSetConfigParam, type TakeoutInfo, type TaskInfo, type TokenInfo, type TowerHealth, TowerHealthStatusEnum, type TowerInfo, TowersApi, TowersApiAxiosParamCreator, TowersApiFactory, TowersApiFp, type UpdateFileParams, type UserInfo, type UserInfoArchive, UsersApi, UsersApiAxiosParamCreator, UsersApiFactory, UsersApiFp, type WLAPI, type WLResponseInfo, WeblensAPIFactory, type WeblensErrorInfo };
