package http

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/ethanrous/weblens/docs"
	_ "github.com/ethanrous/weblens/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/ethanrous/weblens/internal/env"
	"github.com/ethanrous/weblens/internal/log"
	"github.com/ethanrous/weblens/models"
	"github.com/go-chi/chi/v5"
	httpSwagger "github.com/swaggo/http-swagger/v2"
)

type Server struct {
	StartupFunc func()

	router     *chi.Mux
	stdServer  *http.Server
	services   *models.ServicePack
	hostStr    string
	RouterLock sync.Mutex
	Running    bool
}

// @title						Weblens API
// @version					1.0
// @description				Programmatic access to the Weblens server
// @license.name				MIT
// @license.url				https://opensource.org/licenses/MIT
// @host						localhost:8080
// @schemes					http https
// @BasePath					/api/
//
// @securityDefinitions.apikey	SessionAuth
// @in							cookie
// @name						weblens-session-token
//
// @securityDefinitions.apikey	ApiKeyAuth
// @in							header
// @name						Authorization
//
// @scope.admin				Grants read and write access to privileged data
func NewServer(host string, port int, services *models.ServicePack) *Server {

	proxyHost := env.GetProxyAddress(services.Cnf)
	if strings.HasPrefix(proxyHost, "http") {
		i := strings.Index(proxyHost, "://")
		proxyHost = proxyHost[i+3:]
	}
	docs.SwaggerInfo.Host = proxyHost

	srv := &Server{
		router:   chi.NewRouter(),
		services: services,
		hostStr:  fmt.Sprintf("%s:%d", host, port),
	}

	services.Server = srv

	return srv
}

func (s *Server) Start() {
	for {
		if s.services.StartupChan == nil {
			return
		}

		s.router.Get("/docs", func(w http.ResponseWriter, r *http.Request) {
			http.Redirect(w, r, "/docs/", http.StatusMovedPermanently)
		})

		// Kinda hacky, but allows for docs to be served from /docs/ instead of /docs/index.html
		s.router.Get("/docs/*", func(w http.ResponseWriter, r *http.Request) {
			if r.RequestURI == "/docs/" {
				r.RequestURI = "/docs/index.html"
			}
			httpSwagger.WrapHandler(w, r)
		})

		s.router.Mount("/api", s.UseApi())

		if !env.DetachUi() {
			s.router.Mount("/", s.UseUi())
		}

		s.RouterLock.Lock()
		go s.StartupFunc()
		<-s.services.StartupChan
		s.services.Log.Trace.Println("Router got startup signal")

		s.stdServer = &http.Server{Addr: s.hostStr, Handler: s.router, ReadHeaderTimeout: 5 * time.Second}
		s.Running = true

		s.services.Log.Info.Printf("Starting router at %s", s.hostStr)
		s.RouterLock.Unlock()

		err := s.stdServer.ListenAndServe()

		if !errors.Is(err, http.ErrServerClosed) {
			log.Error.Fatalln(err)
		}
		s.RouterLock.Lock()
		s.Running = false
		s.stdServer = nil

		// s.router = gin.New()
		s.router = chi.NewRouter()
		s.RouterLock.Unlock()
	}
}

func (s *Server) UseApi() *chi.Mux {
	r := chi.NewRouter()

	r.Use(log.ApiLogger(s.services.Log), Recoverer, CORSMiddleware(env.GetProxyAddress(s.services.Cnf)), WithServices(s.services), WeblensAuth)

	r.Group(func(r chi.Router) {
		r.Use(AllowPublic)
		r.Get("/info", getServerInfo)
		r.Get("/ws", wsConnect)
	})

	// Media
	r.Route("/media", func(r chi.Router) {
		r.Get("/", getMediaBatch)
		r.Get("/{mediaId}/file", getMediaFile)
		r.Post("/cleanup", cleanupMedia)
		r.Post("/drop", dropMedia)
		r.Patch("/{mediaId}/liked", setMediaLiked)
		r.Patch("/visibility", hideMedia)
		r.Patch("/date", adjustMediaDate)

		r.Group(func(r chi.Router) {
			r.Use(AllowPublic)
			r.Get("/types", getMediaTypes)
			r.Get("/{mediaId}/info", getMediaInfo)
			r.Get("/{mediaId}.{extension}", getMediaImage)
			r.Get("/{mediaId}/stream", streamVideo)
			r.Get("/{mediaId}/{chunkName}", streamVideo)
		})
	})

	// Files
	r.Route("/files", func(r chi.Router) {
		r.Get("/{fileId}", getFile)
		r.Get("/{fileId}/text", getFileText)
		r.Get("/{fileId}/stats", getFileStats)
		r.Get("/{fileId}/download", downloadFile)
		r.Get("/{fileId}/history", getFolderHistory)
		r.Get("/search", searchByFilename)
		r.Get("/autocomplete", autocompletePath)
		r.Get("/shared", getSharedFiles)

		r.Post("/restore", restoreFiles)

		r.Patch("/{fileId}", updateFile)
		r.Patch("/", moveFiles)
		// r.Patch("/trash", trashFiles)
		r.Patch("/untrash", unTrashFiles)
		r.Delete("/", deleteFiles)
	})

	// Folder
	r.Route("/folder", func(r chi.Router) {
		r.Post("/", createFolder)
		r.Patch("/{folderId}/cover", setFolderCover)

		r.Group(func(r chi.Router) {
			r.Use(AllowPublic)
			r.Get("/{folderId}", getFolder)
		})
	})

	// Journal
	r.Route("/journal", func(r chi.Router) {
		r.Get("/", getLifetimesSince)
	})

	// Upload
	r.Route("/upload", func(r chi.Router) {
		r.Get("/{uploadId}", getUploadResult)
		r.Post("/", newUploadTask)
		r.Post("/{uploadId}", newFileUpload)
		r.Put("/{uploadId}/file/{fileId}", handleUploadChunk)
	})

	// Takeout
	r.Post("/takeout", createTakeout)

	// Users
	r.Route("/users", func(r chi.Router) {
		r.Get("/", getUsers)
		r.Get("/me", getUserInfo)
		r.Get("/search", searchUsers)
		r.Post("/", createUser)

		// Must not use weblens auth here, as the user is not logged in yet
		r.Group(func(r chi.Router) {
			r.Use(AllowPublic)
			r.Post("/auth", loginUser)
			r.Get("/unique", checkUsernameUnique)
		})

		r.Post("/logout", logoutUser)
		r.Patch("/{username}/password", updateUserPassword)
		r.Patch("/{username}/admin", setUserAdmin)
		r.Patch("/{username}/active", activateUser)
		r.Patch("/{username}/fullName", changeFullName)
		r.Delete("/{username}", deleteUser)
	})

	// Share
	r.Route("/share", func(r chi.Router) {
		r.Get("/{shareId}", getFileShare)
		r.Post("/file", createFileShare)
		r.Post("/album", createAlbumShare)
		r.Patch("/{shareId}/accessors", setShareAccessors)
		r.Patch("/{shareId}/public", setSharePublic)
		r.Delete("/{shareId}", deleteShare)
	})

	// Albums
	// r.Route("/albums", func(r chi.Router) {
	// 	r.Get("/", getAlbums)
	// 	r.Get("/{albumId}", getAlbum)
	// 	r.Get("/{albumId}/media", getAlbumMedia)
	// 	r.Post("/album", createAlbum)
	// 	r.Patch("/{albumId}", updateAlbum)
	// 	r.Delete("/{albumId}", deleteAlbum)
	// })

	// ApiKeys
	r.Route("/keys", func(r chi.Router) {
		r.Get("/", getApiKeys)
		r.Post("/", newApiKey)
		r.Delete("/{keyId}", deleteApiKey)
	})

	// Servers
	r.Route("/servers", func(r chi.Router) {
		r.Group(func(r chi.Router) {
			r.Use(AllowPublic)
			r.Post("/init", initializeServer)
			r.Post("/reset", resetServer)
		})

		r.Group(func(r chi.Router) {
			r.Use(RequireAdmin)
			r.Get("/", getRemotes)
			r.Post("/", attachRemote)

			r.Get("/backup", doFullBackup)

			r.Post("/{serverId}/backup", launchBackup)
			r.Post("/{serverId}/restore", restoreToCore)
			r.Delete("/{serverId}", removeRemote)

		})
	})

	/* Static content */
	r.Get("/static/{filename}", serveStaticContent)

	return r
}

func (s *Server) UseUi() *chi.Mux {
	memFs := &InMemoryFS{routes: make(map[string]*memFileReal, 10), routesMu: &sync.RWMutex{}, Pack: s.services, proxyAddress: env.GetProxyAddress(s.services.Cnf)}
	memFs.loadIndex(s.services.Cnf.UiPath)

	r := chi.NewMux()
	r.Route("/assets", func(r chi.Router) {
		r.Use(func(next http.Handler) http.Handler {
			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Cache-Control", "public, max-age=3600")
				w.Header().Set("Content-Encoding", "gzip")
				next.ServeHTTP(w, r)
			})
		})
		r.Handle("/*", http.FileServer(memFs))
	})

	r.NotFound(
		func(w http.ResponseWriter, r *http.Request) {
			if !strings.HasPrefix(r.RequestURI, "/api") {
				log.Trace.Func(func(l log.Logger) { l.Printf("Serving index.html for %s", r.RequestURI) })
				index := memFs.Index(r.RequestURI)
				_, err := w.Write(index.realFile.data)
				SafeErrorAndExit(err, w)
			} else {
				w.WriteHeader(http.StatusNotFound)
				return
			}
		},
	)

	return r
}

var staticDir = ""

func serveStaticContent(w http.ResponseWriter, r *http.Request) {
	filename := chi.URLParam(r, "filename")

	if staticDir == "" {
		testDir := filepath.Join(env.GetAppRootDir(), "/static")
		_, err := os.Stat(testDir)
		if err != nil {
			testDir = filepath.Join(env.GetAppRootDir(), "/images/brand/")
			_, err = os.Stat(testDir)
			if err != nil {
				panic(err)
			}
		}
		staticDir = testDir
	}

	fullPath := filepath.Join(staticDir, filename)
	f, err := os.Open(fullPath)
	if SafeErrorAndExit(err, w) {
		return
	}

	_, err = io.Copy(w, f)
	SafeErrorAndExit(err, w)
}

func (s *Server) Restart(wait bool) {
	s.services.Loaded.Store(false)
	s.services.StartupChan = make(chan bool)
	err := s.stdServer.Shutdown(context.Background())
	if err != nil {
		panic(err)
	}

	if wait {
		<-s.services.StartupChan
	}
}

func (s *Server) Stop() {
	s.services.Log.Debug.Println("Stopping server", s.services.InstanceService.GetLocal().GetName())
	s.services.Closing.Store(true)
	s.services.Caster.PushWeblensEvent(models.ServerGoingDownEvent)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	err := s.stdServer.Shutdown(ctx)
	s.services.Log.ErrTrace(err)
	s.services.Log.ErrTrace(ctx.Err())

	for _, c := range s.services.ClientService.GetAllClients() {
		s.services.ClientService.ClientDisconnect(c)
	}
}
