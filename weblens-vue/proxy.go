package main

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"os/signal"
	"syscall"
)

const (
	red   = "\033[31m"
	reset = "\033[0m"
)

type statusRecorder struct {
	http.ResponseWriter
	status int
}

func (rec *statusRecorder) WriteHeader(code int) {
	rec.status = code

	if code != http.StatusNotFound {
		rec.ResponseWriter.WriteHeader(code)
	}
}

func (w *statusRecorder) Write(p []byte) (int, error) {
	if w.status != http.StatusNotFound {
		return w.ResponseWriter.Write(p)
	}
	return len(p), nil // Lie that we successfully written it
}

func getAPIAddr() string {
	addr := os.Getenv("WEBLENS_API_ADDRESS")
	if addr == "" {
		addr = "http://localhost:8080"
	}

	return addr
}

func getUiPath() string {
	path := os.Getenv("WEBLENS_NUXT_UI_PATH")
	if path == "" {
		path = "/dist/"
	}

	return path
}

func addStaticRoutes(r *http.ServeMux, uiFilesPath string) {
	// Open a fs handler to serve the files generated by nuxt generate
	fs := http.FileServer(http.Dir(uiFilesPath))

	// Any rotues that match "/*" are going to be querying
	// our local build of the app, so we route those to the generated files
	r.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		recorder := &statusRecorder{ResponseWriter: w}
		w.Header().Set("Cache-Control", "max-age=31536000")

		fs.ServeHTTP(recorder, r)

		if recorder.status == http.StatusNotFound {
			w.Header().Set("Content-Type", "text/html; charset=utf-8")
			http.ServeFile(w, r, uiFilesPath+"/index.html")
		}
	})

}

func newProxy(target string) (*httputil.ReverseProxy, error) {
	proxyUrl, err := url.Parse(target)
	if err != nil {
		return nil, err
	}

	fmt.Println("Setting up api proxy to", proxyUrl.String())

	proxy := &httputil.ReverseProxy{
		Rewrite: func(r *httputil.ProxyRequest) {
			r.SetURL(proxyUrl)
			r.Out.Host = r.In.Host
		},
		// Silence errors
		// ErrorHandler: func(w http.ResponseWriter, r *http.Request, err error) {
		// },
	}

	return proxy, nil
}

func main() {
	wlAPIProxy, err := newProxy(getAPIAddr())
	if err != nil {
		panic(err)
	}

	// Setup router
	r := http.NewServeMux()

	ctx, cancel := context.WithCancel(context.Background())

	// Handle OS signals for graceful shutdown
	sigc := make(chan os.Signal, 1)
	signal.Notify(sigc,
		syscall.SIGHUP,
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGQUIT)
	go func() {
		<-sigc
		cancel()
	}()

	// API routes go to the API proxy
	r.HandleFunc("/api/v1/", wlApiProxy.ServeHTTP)

	// Everything else not matched above goes to the UI
	addStaticRoutes(r, getUiPath())

	server := http.Server{
		Addr:    "0.0.0.0:8989",
		Handler: r,
	}

	fmt.Println("Setup complete âœ… Starting proxy at \033[0;33mhttp://localhost:8989\033[0m")

	go func() {
		err = server.ListenAndServe()
		if err != http.ErrServerClosed {
			fmt.Printf("%sERROR From Router: %v%s\n", red, err, reset)

			cancel()
		}
	}()

	<-ctx.Done()

	fmt.Printf("%sShutting down proxy%s\n", red, reset)

	// Do graceful shutdown
	err = server.Shutdown(context.Background())

	if err != nil {
		fmt.Printf("%s[ERROR] during shutdown: %v%s\n", red, err, reset)
	}
}
