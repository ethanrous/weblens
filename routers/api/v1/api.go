package v1

import (
	"io"
	"net/http"
	"os"
	"path/filepath"

	_ "github.com/ethanrous/weblens/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/ethanrous/weblens/modules/config"
	file_api "github.com/ethanrous/weblens/routers/api/v1/file"
	media_api "github.com/ethanrous/weblens/routers/api/v1/media"
	tower_api "github.com/ethanrous/weblens/routers/api/v1/tower"
	user_api "github.com/ethanrous/weblens/routers/api/v1/user"
	"github.com/ethanrous/weblens/routers/api/v1/websocket"
	"github.com/ethanrous/weblens/routers/router"
	api_ctx "github.com/ethanrous/weblens/services/context"

	httpSwagger "github.com/swaggo/http-swagger/v2"
)

// func NewServer(host string, port int, services *models.ServicePack) *Server {
//
// 	proxyHost := env.GetProxyAddress(services.Cnf)
// 	if strings.HasPrefix(proxyHost, "http") {
// 		i := strings.Index(proxyHost, "://")
// 		proxyHost = proxyHost[i+3:]
// 	}
// 	docs.SwaggerInfo.Host = proxyHost
//
// 	srv := &Server{
// 		router:   chi.NewRouter(),
// 		services: services,
// 		hostStr:  fmt.Sprintf("%s:%d", host, port),
// 	}
//
// 	services.Server = srv
//
// 	return srv
// }

func Routes() *router.Router {
	r := router.NewRouter()

	// r.Use(router.LoggerMiddlewares(*s.services.Log)...)
	// r.Use(
	// 	Recoverer,
	// 	CORSMiddleware(env.GetProxyAddress(s.services.Cnf)),
	// 	WithServices(s.services),
	// 	WeblensAuth,
	// )

	r.Get("/info", tower_api.GetServerInfo)
	r.Get("/ws", websocket.Connect)

	// Media
	r.Group("/media", func() {
		r.Get("/types", media_api.GetMediaTypes)
		r.Group("/{mediaId}", func() {
			r.Get("/info", media_api.GetMediaInfo)
			r.Get(".{extension}", media_api.GetMediaImage)
			r.Get("/stream", media_api.StreamVideo)
			r.Get("/{chunkName}", media_api.StreamVideo)
			r.Patch("/liked", router.RequireSignIn, media_api.SetMediaLiked)
		})

		r.Group("", func() {
			r.Get("/", media_api.GetMediaBatch)
			r.Get("/{mediaId}/file", media_api.GetMediaFile)
			r.Post("/cleanup", media_api.CleanupMedia)
			r.Post("/drop", media_api.DropMedia)
			r.Patch("/visibility", media_api.HideMedia)
			r.Patch("/date", media_api.AdjustMediaDate)
		}, router.RequireSignIn)
	})

	// Files
	r.Group("/files", func() {
		r.Group("/{fileId}", func() {
			r.Get("", file_api.GetFile)
			r.Patch("", file_api.UpdateFile)
			r.Get("/text", file_api.GetFileText)
			r.Get("/stats", file_api.GetFileStats)
			r.Get("/download", file_api.DownloadFile)
			r.Get("/history", file_api.GetFolderHistory)
		})

		r.Patch("", file_api.MoveFiles)
		r.Delete("", file_api.DeleteFiles)
		r.Get("/search", file_api.SearchByFilename)
		r.Get("/autocomplete", file_api.AutocompletePath)
		r.Patch("/untrash", file_api.UnTrashFiles)
		r.Post("/restore", file_api.RestoreFiles)
		r.Get("/shared", file_api.GetSharedFiles)
	})

	// Folder
	r.Group("/folder", func() {

		r.Group("/{folderId}", func() {
			r.Get("", file_api.GetFolder)
			r.Patch("/cover", router.RequireSignIn, file_api.SetFolderCover)
		})

		r.Post("", router.RequireSignIn, file_api.CreateFolder)
	})

	// Journal
	// r.Route("/journal", func(r *router.Router) {
	// 	r.Get("/", getLifetimesSince)
	// })

	// Upload
	r.Group("/upload", func() {
		r.Post("", file_api.NewUploadTask)
		r.Group("/{uploadId}", func() {
			r.Get("", file_api.GetUploadResult)
			r.Post("", file_api.NewFileUpload)
			r.Put("/file/{fileId}", file_api.HandleUploadChunk)
		})
	}, router.RequireSignIn)

	// Takeout
	// r.Post("/takeout", createTakeout)

	// Users
	r.Group("/users", func() {
		// Must not use weblens auth here, as the user is not logged in yet
		r.Post("/auth", user_api.Login)
		r.Head("/unique", user_api.CheckExists)

		r.Group("", func() {
			r.Get("", user_api.GetAll)
			r.Post("", user_api.Create)
			r.Get("/me", user_api.GetMe)
			r.Get("/search", user_api.Search)
			r.Post("/logout", user_api.Logout)

			r.Group("/{username}", func() {
				r.Patch("/password", user_api.UpdatePassword)
				r.Patch("/admin", user_api.SetAdmin)
				r.Patch("/active", user_api.Activate)
				r.Patch("/fullName", user_api.ChangeDisplayName)
				r.Delete("", user_api.Delete)
			})
		}, router.RequireSignIn)

	})

	// Share
	// r.Route("/share", func(r *router.Router) {
	// 	r.Get("/{shareId}", getFileShare)
	// 	r.Post("/file", createFileShare)
	// 	r.Post("/album", createAlbumShare)
	// 	r.Patch("/{shareId}/accessors", setShareAccessors)
	// 	r.Patch("/{shareId}/public", setSharePublic)
	// 	r.Delete("/{shareId}", deleteShare)
	// })

	// ApiKeys
	// r.Route("/keys", func(r *router.Router) {
	// 	r.Get("/", getApiKeys)
	// 	r.Post("/", user_api.CreateApiKey)
	// 	r.Delete("/{keyId}", deleteApiKey)
	// })

	// Servers
	r.Route("/tower", func(r *router.Router) {
		r.Post("/init", tower_api.InitializeTower)

		// r.Group(func(r *router.Router) {
		// 	r.Use(RequireAdmin)
		// 	r.Get("/", getRemotes)
		// 	r.Post("/", attachRemote)
		//
		// 	r.Get("/backup", doFullBackup)
		//
		// 	r.Post("/reset", resetServer)
		//
		// 	r.Post("/{serverId}/backup", launchBackup)
		// 	r.Post("/{serverId}/restore", restoreToCore)
		// 	r.Patch("/{serverId}", updateRemote)
		// 	r.Delete("/{serverId}", removeRemote)
		//
		// })
	})

	/* Static content */
	r.Get("/static/{filename}", serveStaticContent)

	return r
}

func Docs() *router.Router {
	r := router.NewRouter()

	r.Get("/", func(ctx *api_ctx.RequestContext) {
		http.Redirect(ctx.W, ctx.Req, "/docs/", http.StatusMovedPermanently)
	})

	// Kinda hacky, but allows for docs to be served from /docs/ instead of /docs/index.html
	r.Get("/*", func(ctx *api_ctx.RequestContext) {
		if ctx.Req.RequestURI == "/docs/" {
			ctx.Req.RequestURI = "/docs/index.html"
		}
		httpSwagger.WrapHandler(ctx.W, ctx.Req)
	})

	return r
}

var staticDir = ""

func serveStaticContent(ctx *api_ctx.RequestContext) {
	filename := ctx.Path("filename")

	cnf := config.GetConfig()

	if staticDir == "" {
		testDir := filepath.Join(cnf.StaticContentPath, "/static")
		_, err := os.Stat(testDir)
		if err != nil {
			panic(err)
		}
		staticDir = testDir
	}

	fullPath := filepath.Join(staticDir, filename)
	f, err := os.Open(fullPath)
	if err != nil {
		ctx.Error(http.StatusNotFound, err)
		return
	}
	defer f.Close()

	_, err = io.Copy(ctx.W, f)
	if err != nil {
		ctx.Error(http.StatusInternalServerError, err)
		return
	}

	ctx.Status(http.StatusOK)
}
