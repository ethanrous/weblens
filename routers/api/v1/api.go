package v1

import (
	"io"
	"net/http"
	"os"
	"path/filepath"

	_ "github.com/ethanrous/weblens/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/ethanrous/weblens/modules/config"
	tower_api "github.com/ethanrous/weblens/routers/api/v1/tower"
	user_api "github.com/ethanrous/weblens/routers/api/v1/user"
	"github.com/ethanrous/weblens/routers/api/v1/websocket"
	"github.com/ethanrous/weblens/routers/router"
	api_ctx "github.com/ethanrous/weblens/services/context"

	httpSwagger "github.com/swaggo/http-swagger/v2"
)

// func NewServer(host string, port int, services *models.ServicePack) *Server {
//
// 	proxyHost := env.GetProxyAddress(services.Cnf)
// 	if strings.HasPrefix(proxyHost, "http") {
// 		i := strings.Index(proxyHost, "://")
// 		proxyHost = proxyHost[i+3:]
// 	}
// 	docs.SwaggerInfo.Host = proxyHost
//
// 	srv := &Server{
// 		router:   chi.NewRouter(),
// 		services: services,
// 		hostStr:  fmt.Sprintf("%s:%d", host, port),
// 	}
//
// 	services.Server = srv
//
// 	return srv
// }

func Routes() *router.Router {
	r := router.NewRouter()

	// r.Use(router.LoggerMiddlewares(*s.services.Log)...)
	// r.Use(
	// 	Recoverer,
	// 	CORSMiddleware(env.GetProxyAddress(s.services.Cnf)),
	// 	WithServices(s.services),
	// 	WeblensAuth,
	// )

	r.Group(func(r *router.Router) {
		r.Get("/info", tower_api.GetServerInfo)
		r.Get("/ws", websocket.Connect)
	})

	// Media
	// r.Route("/media", func(r *router.Router) {
	// 	r.Get("/types", getMediaTypes)
	// 	r.Get("/{mediaId}/info", getMediaInfo)
	// 	r.Get("/{mediaId}.{extension}", getMediaImage)
	// 	r.Get("/{mediaId}/stream", streamVideo)
	// 	r.Get("/{mediaId}/{chunkName}", streamVideo)
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireSignIn)
	// 		r.Get("/", getMediaBatch)
	// 		r.Get("/{mediaId}/file", getMediaFile)
	// 		r.Post("/cleanup", cleanupMedia)
	// 		r.Post("/drop", dropMedia)
	// 		r.Patch("/{mediaId}/liked", setMediaLiked)
	// 		r.Patch("/visibility", hideMedia)
	// 		r.Patch("/date", adjustMediaDate)
	// 	})
	// })

	// Files
	// r.Route("/files", func(r *router.Router) {
	// 	r.Get("/{fileId}", getFile)
	// 	r.Get("/{fileId}/text", getFileText)
	// 	r.Get("/{fileId}/stats", getFileStats)
	// 	r.Get("/{fileId}/download", downloadFile)
	// 	r.Get("/{fileId}/history", getFolderHistory)
	// 	r.Get("/search", searchByFilename)
	// 	r.Get("/autocomplete", autocompletePath)
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireSignIn)
	// 		r.Patch("/", moveFiles)
	// 		r.Delete("/", deleteFiles)
	// 		r.Patch("/untrash", unTrashFiles)
	// 		r.Post("/restore", restoreFiles)
	// 		r.Patch("/{fileId}", updateFile)
	// 		r.Get("/shared", getSharedFiles)
	// 	})
	// })

	// Folder
	// r.Route("/folder", func(r *router.Router) {
	// 	r.Get("/{folderId}", getFolder)
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireSignIn)
	// 		r.Post("/", createFolder)
	// 		r.Patch("/{folderId}/cover", setFolderCover)
	// 	})
	// })

	// Journal
	// r.Route("/journal", func(r *router.Router) {
	// 	r.Get("/", getLifetimesSince)
	// })

	// Upload
	// r.Route("/upload", func(r *router.Router) {
	// 	r.Use(RequireSignIn)
	// 	r.Get("/{uploadId}", getUploadResult)
	// 	r.Post("/", newUploadTask)
	// 	r.Post("/{uploadId}", newFileUpload)
	// 	r.Put("/{uploadId}/file/{fileId}", handleUploadChunk)
	// })

	// Takeout
	// r.Post("/takeout", createTakeout)

	// Users
	r.Route("/users", func(r *router.Router) {
		r.Post("/auth", user_api.Login)
		r.Head("/unique", user_api.CheckExists)

		// Must not use weblens auth here, as the user is not logged in yet
		r.Group(func(r *router.Router) {
			r.Get("/", user_api.GetAll)
			r.Post("/", user_api.Create)
			r.Get("/me", user_api.GetMe)
			r.Get("/search", user_api.Search)
			r.Post("/logout", user_api.Logout)

			r.Route("/{username}", func(r *router.Router) {
				r.Patch("/password", user_api.UpdatePassword)
				r.Patch("/admin", user_api.SetAdmin)
				r.Patch("/active", user_api.Activate)
				r.Patch("/fullName", user_api.ChangeDisplayName)
				r.Delete("/", user_api.Delete)
			})
		})

	})

	// Share
	// r.Route("/share", func(r *router.Router) {
	// 	r.Get("/{shareId}", getFileShare)
	// 	r.Post("/file", createFileShare)
	// 	r.Post("/album", createAlbumShare)
	// 	r.Patch("/{shareId}/accessors", setShareAccessors)
	// 	r.Patch("/{shareId}/public", setSharePublic)
	// 	r.Delete("/{shareId}", deleteShare)
	// })

	// ApiKeys
	// r.Route("/keys", func(r *router.Router) {
	// 	r.Get("/", getApiKeys)
	// 	r.Post("/", user_api.CreateApiKey)
	// 	r.Delete("/{keyId}", deleteApiKey)
	// })

	// Servers
	// r.Route("/servers", func(r *router.Router) {
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(AllowPublic)
	// 		r.Post("/init", initializeServer)
	// 	})
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireAdmin)
	// 		r.Get("/", getRemotes)
	// 		r.Post("/", attachRemote)
	//
	// 		r.Get("/backup", doFullBackup)
	//
	// 		r.Post("/reset", resetServer)
	//
	// 		r.Post("/{serverId}/backup", launchBackup)
	// 		r.Post("/{serverId}/restore", restoreToCore)
	// 		r.Patch("/{serverId}", updateRemote)
	// 		r.Delete("/{serverId}", removeRemote)
	//
	// 	})
	// })

	/* Static content */
	r.Get("/static/{filename}", serveStaticContent)

	return r
}

func Docs() *router.Router {
	r := router.NewRouter()

	r.Get("/", func(ctx *api_ctx.RequestContext) {
		http.Redirect(ctx.W, ctx.Req, "/docs/", http.StatusMovedPermanently)
	})

	// Kinda hacky, but allows for docs to be served from /docs/ instead of /docs/index.html
	r.Get("/*", func(ctx *api_ctx.RequestContext) {
		if ctx.Req.RequestURI == "/docs/" {
			ctx.Req.RequestURI = "/docs/index.html"
		}
		httpSwagger.WrapHandler(ctx.W, ctx.Req)
	})

	return r
}

var staticDir = ""

func serveStaticContent(ctx *api_ctx.RequestContext) {
	filename := ctx.Path("filename")

	cnf := config.GetConfig()

	if staticDir == "" {
		testDir := filepath.Join(cnf.StaticContentPath, "/static")
		_, err := os.Stat(testDir)
		if err != nil {
			panic(err)
		}
		staticDir = testDir
	}

	fullPath := filepath.Join(staticDir, filename)
	f, err := os.Open(fullPath)
	if err != nil {
		ctx.Error(http.StatusNotFound, err)
		return
	}
	defer f.Close()

	_, err = io.Copy(ctx.W, f)
	if err != nil {
		ctx.Error(http.StatusInternalServerError, err)
		return
	}

	ctx.W.WriteHeader(http.StatusOK)
}
