package v1

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/ethanrous/weblens/docs"
	_ "github.com/ethanrous/weblens/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/ethanrous/weblens/internal/env"
	"github.com/ethanrous/weblens/models"
	tower_api "github.com/ethanrous/weblens/routers/api/v1/tower"
	user_api "github.com/ethanrous/weblens/routers/api/v1/user"
	"github.com/ethanrous/weblens/routers/api/v1/websocket"
	"github.com/ethanrous/weblens/routers/router"
	api_ctx "github.com/ethanrous/weblens/services/context"
	"github.com/go-chi/chi/v5"
	"github.com/rs/zerolog"
	httpSwagger "github.com/swaggo/http-swagger/v2"
)

type Server struct {
	StartupFunc func()

	router     *chi.Mux
	stdServer  *http.Server
	services   *models.ServicePack
	hostStr    string
	RouterLock sync.Mutex
	Running    bool
}

// @title						Weblens API
// @version					1.0
// @description				Programmatic access to the Weblens server
// @license.name				MIT
// @license.url				https://opensource.org/licenses/MIT
// @host						localhost:8080
// @schemes					http https
// @BasePath					/api/
//
// @securityDefinitions.apikey	SessionAuth
// @in							cookie
// @name						weblens-session-token
//
// @securityDefinitions.apikey	ApiKeyAuth
// @in							header
// @name						Authorization
//
// @scope.admin				Grants read and write access to privileged data
func NewServer(host string, port int, services *models.ServicePack) *Server {

	proxyHost := env.GetProxyAddress(services.Cnf)
	if strings.HasPrefix(proxyHost, "http") {
		i := strings.Index(proxyHost, "://")
		proxyHost = proxyHost[i+3:]
	}
	docs.SwaggerInfo.Host = proxyHost

	srv := &Server{
		router:   chi.NewRouter(),
		services: services,
		hostStr:  fmt.Sprintf("%s:%d", host, port),
	}

	services.Server = srv

	return srv
}

func (s *Server) Start() {
	for {
		if s.services.StartupChan == nil {
			return
		}

		s.router.Get("/docs", func(w http.ResponseWriter, r *http.Request) {
			http.Redirect(w, r, "/docs/", http.StatusMovedPermanently)
		})

		// Kinda hacky, but allows for docs to be served from /docs/ instead of /docs/index.html
		s.router.Get("/docs/*", func(w http.ResponseWriter, r *http.Request) {
			if r.RequestURI == "/docs/" {
				r.RequestURI = "/docs/index.html"
			}
			httpSwagger.WrapHandler(w, r)
		})

		s.router.Mount("/api", s.UseApi())

		if !env.DetachUi() {
			s.router.Mount("/", s.UseUi())
		}

		s.RouterLock.Lock()
		go s.StartupFunc()

		startupCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)

		select {
		case <-s.services.StartupChan:
			cancel()
		case <-startupCtx.Done():
			cancel()
			s.services.Log.WithLevel(zerolog.FatalLevel).Msg("Server startup timed out, exiting")
			os.Exit(1)
		}
		s.services.Log.Debug().Msg("Startup function signaled to continue")

		s.stdServer = &http.Server{Addr: s.hostStr, Handler: s.router, ReadHeaderTimeout: 5 * time.Second}
		s.Running = true

		s.services.Log.Debug().Msgf("Starting router at %s", s.hostStr)
		s.RouterLock.Unlock()

		err := s.stdServer.ListenAndServe()

		if !errors.Is(err, http.ErrServerClosed) {
			s.services.Log.Fatal().Err(err).Msg("Error starting server")
		}
		s.RouterLock.Lock()
		s.Running = false
		s.stdServer = nil

		// s.router = gin.New()
		s.router = chi.NewRouter()
		s.RouterLock.Unlock()
	}
}

func Routes() *router.Router {
	r := router.NewRouter()

	// r.Use(router.LoggerMiddlewares(*s.services.Log)...)
	// r.Use(
	// 	Recoverer,
	// 	CORSMiddleware(env.GetProxyAddress(s.services.Cnf)),
	// 	WithServices(s.services),
	// 	WeblensAuth,
	// )

	r.Group(func(r *router.Router) {
		r.Get("/info", tower_api.GetServerInfo)
		r.Get("/ws", websocket.Connect)
	})

	// Media
	// r.Route("/media", func(r *router.Router) {
	// 	r.Get("/types", getMediaTypes)
	// 	r.Get("/{mediaId}/info", getMediaInfo)
	// 	r.Get("/{mediaId}.{extension}", getMediaImage)
	// 	r.Get("/{mediaId}/stream", streamVideo)
	// 	r.Get("/{mediaId}/{chunkName}", streamVideo)
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireSignIn)
	// 		r.Get("/", getMediaBatch)
	// 		r.Get("/{mediaId}/file", getMediaFile)
	// 		r.Post("/cleanup", cleanupMedia)
	// 		r.Post("/drop", dropMedia)
	// 		r.Patch("/{mediaId}/liked", setMediaLiked)
	// 		r.Patch("/visibility", hideMedia)
	// 		r.Patch("/date", adjustMediaDate)
	// 	})
	// })

	// Files
	// r.Route("/files", func(r *router.Router) {
	// 	r.Get("/{fileId}", getFile)
	// 	r.Get("/{fileId}/text", getFileText)
	// 	r.Get("/{fileId}/stats", getFileStats)
	// 	r.Get("/{fileId}/download", downloadFile)
	// 	r.Get("/{fileId}/history", getFolderHistory)
	// 	r.Get("/search", searchByFilename)
	// 	r.Get("/autocomplete", autocompletePath)
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireSignIn)
	// 		r.Patch("/", moveFiles)
	// 		r.Delete("/", deleteFiles)
	// 		r.Patch("/untrash", unTrashFiles)
	// 		r.Post("/restore", restoreFiles)
	// 		r.Patch("/{fileId}", updateFile)
	// 		r.Get("/shared", getSharedFiles)
	// 	})
	// })

	// Folder
	// r.Route("/folder", func(r *router.Router) {
	// 	r.Get("/{folderId}", getFolder)
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireSignIn)
	// 		r.Post("/", createFolder)
	// 		r.Patch("/{folderId}/cover", setFolderCover)
	// 	})
	// })

	// Journal
	// r.Route("/journal", func(r *router.Router) {
	// 	r.Get("/", getLifetimesSince)
	// })

	// Upload
	// r.Route("/upload", func(r *router.Router) {
	// 	r.Use(RequireSignIn)
	// 	r.Get("/{uploadId}", getUploadResult)
	// 	r.Post("/", newUploadTask)
	// 	r.Post("/{uploadId}", newFileUpload)
	// 	r.Put("/{uploadId}/file/{fileId}", handleUploadChunk)
	// })

	// Takeout
	// r.Post("/takeout", createTakeout)

	// Users
	r.Route("/users", func(r *router.Router) {
		r.Post("/auth", user_api.Login)
		r.Head("/unique", user_api.CheckExists)

		// Must not use weblens auth here, as the user is not logged in yet
		r.Group(func(r *router.Router) {
			r.Get("/", user_api.GetAll)
			r.Post("/", user_api.Create)
			r.Get("/me", user_api.GetMe)
			r.Get("/search", user_api.Search)
			r.Post("/logout", user_api.Logout)

			r.Route("/{username}", func(r *router.Router) {
				r.Patch("/password", user_api.UpdatePassword)
				r.Patch("/admin", user_api.SetAdmin)
				r.Patch("/active", user_api.Activate)
				r.Patch("/fullName", user_api.ChangeDisplayName)
				r.Delete("/", user_api.Delete)
			})
		})

	})

	// Share
	// r.Route("/share", func(r *router.Router) {
	// 	r.Get("/{shareId}", getFileShare)
	// 	r.Post("/file", createFileShare)
	// 	r.Post("/album", createAlbumShare)
	// 	r.Patch("/{shareId}/accessors", setShareAccessors)
	// 	r.Patch("/{shareId}/public", setSharePublic)
	// 	r.Delete("/{shareId}", deleteShare)
	// })

	// ApiKeys
	// r.Route("/keys", func(r *router.Router) {
	// 	r.Get("/", getApiKeys)
	// 	r.Post("/", user_api.CreateApiKey)
	// 	r.Delete("/{keyId}", deleteApiKey)
	// })

	// Servers
	// r.Route("/servers", func(r *router.Router) {
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(AllowPublic)
	// 		r.Post("/init", initializeServer)
	// 	})
	//
	// 	r.Group(func(r *router.Router) {
	// 		r.Use(RequireAdmin)
	// 		r.Get("/", getRemotes)
	// 		r.Post("/", attachRemote)
	//
	// 		r.Get("/backup", doFullBackup)
	//
	// 		r.Post("/reset", resetServer)
	//
	// 		r.Post("/{serverId}/backup", launchBackup)
	// 		r.Post("/{serverId}/restore", restoreToCore)
	// 		r.Patch("/{serverId}", updateRemote)
	// 		r.Delete("/{serverId}", removeRemote)
	//
	// 	})
	// })

	/* Static content */
	r.Get("/static/{filename}", serveStaticContent)

	return r
}

var staticDir = ""

func serveStaticContent(ctx api_ctx.RequestContext) {
	filename := ctx.Path("filename")

	if staticDir == "" {
		testDir := filepath.Join(env.GetAppRootDir(), "/static")
		_, err := os.Stat(testDir)
		if err != nil {
			testDir = filepath.Join(env.GetAppRootDir(), "/images/brand/")
			_, err = os.Stat(testDir)
			if err != nil {
				panic(err)
			}
		}
		staticDir = testDir
	}

	fullPath := filepath.Join(staticDir, filename)
	f, err := os.Open(fullPath)
	if err != nil {
		ctx.Error(http.StatusNotFound, err)
		return
	}
	defer f.Close()

	_, err = io.Copy(ctx.W, f)
	if err != nil {
		ctx.Error(http.StatusInternalServerError, err)
		return
	}

	ctx.W.WriteHeader(http.StatusOK)
}

func (s *Server) Restart(wait bool) {
	s.services.Loaded.Store(false)
	s.services.StartupChan = make(chan bool)
	err := s.stdServer.Shutdown(context.Background())
	if err != nil {
		panic(err)
	}

	if wait {
		<-s.services.StartupChan
	}
}

func (s *Server) Stop() {
	s.services.Log.Debug().Func(func(e *zerolog.Event) { e.Msg("Stopping server") })
	s.services.Closing.Store(true)
	s.services.Caster.PushWeblensEvent(models.ServerGoingDownEvent)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	err := s.stdServer.Shutdown(ctx)
	if err != nil {
		s.services.Log.Error().Stack().Err(err).Msg("Error shutting down server")
	}

	for _, c := range s.services.ClientService.GetAllClients() {
		s.services.ClientService.ClientDisconnect(c)
	}
}
