package v1

import (
	"net/http"

	_ "github.com/ethanrous/weblens/docs" // docs is generated by Swag CLI, you have to import it.
	backup_api "github.com/ethanrous/weblens/routers/api/v1/backup"
	file_api "github.com/ethanrous/weblens/routers/api/v1/file"
	history_api "github.com/ethanrous/weblens/routers/api/v1/history"
	media_api "github.com/ethanrous/weblens/routers/api/v1/media"
	tower_api "github.com/ethanrous/weblens/routers/api/v1/tower"
	user_api "github.com/ethanrous/weblens/routers/api/v1/user"
	"github.com/ethanrous/weblens/routers/api/v1/websocket"
	"github.com/ethanrous/weblens/routers/router"
	context_service "github.com/ethanrous/weblens/services/context"

	httpSwagger "github.com/swaggo/http-swagger/v2"
)

func Routes(ctx context_service.AppContext) *router.Router {
	r := router.NewRouter()

	r.Use(
		router.WeblensAuth,
		router.ShareInjector,
	)

	r.Get("/info", tower_api.GetServerInfo)
	r.Get("/ws", websocket.Connect)

	// Media
	r.Group("/media", func() {
		r.Get("/types", media_api.GetMediaTypes)
		r.Group("/{mediaId}", func() {
			r.Get("/info", media_api.GetMediaInfo)
			r.Get(".{extension}", media_api.GetMediaImage)
			r.Get("/stream", media_api.StreamVideo)
			r.Get("/{chunkName}", media_api.StreamVideo)
			r.Patch("/liked", router.RequireSignIn, media_api.SetMediaLiked)
		})

		r.Group("", func() {
			r.Get("", media_api.GetMediaBatch)
			r.Get("/{mediaId}/file", media_api.GetMediaFile)
			r.Post("/cleanup", media_api.CleanupMedia)
			r.Post("/drop", media_api.DropMedia)
			r.Patch("/visibility", media_api.HideMedia)
			r.Patch("/date", media_api.AdjustMediaDate)
		}, router.RequireSignIn)
	})

	// Files
	r.Group("/files", func() {
		r.Patch("", file_api.MoveFiles)
		r.Delete("", file_api.DeleteFiles)
		r.Get("/search", file_api.SearchByFilename)
		r.Get("/autocomplete", file_api.AutocompletePath)
		r.Patch("/untrash", file_api.UnTrashFiles)
		r.Post("/restore", file_api.RestoreFiles)
		r.Get("/shared", file_api.GetSharedFiles)

		r.Group("/{fileId}", func() {
			r.Get("", file_api.GetFile)
			r.Patch("", file_api.UpdateFile)
			r.Get("/text", file_api.GetFileText)
			r.Get("/stats", file_api.GetFileStats)
			r.Get("/download", file_api.DownloadFile)
			r.Get("/history", file_api.GetFolderHistory)
		})
	})

	// Folder
	r.Group("/folder", func() {
		r.Group("/{folderId}", func() {
			r.Get("", file_api.GetFolder)
			r.Patch("/cover", router.RequireSignIn, file_api.SetFolderCover)
		})

		r.Post("", router.RequireSignIn, file_api.CreateFolder)
	})

	// Journal
	// r.Get("/journal", getLifetimesSince)

	// Upload
	r.Group("/upload", func() {
		r.Post("", file_api.NewUploadTask)
		r.Group("/{uploadId}", func() {
			r.Get("", file_api.GetUploadResult)
			r.Post("", file_api.NewFileUpload)
			r.Put("/file/{fileId}", file_api.HandleUploadChunk)
		})
	}, router.RequireSignIn, router.RequireCoreTower)

	// Takeout
	r.Post("/takeout", file_api.CreateTakeout)

	// Users
	r.Group("/users", func() {
		// Must not use weblens auth here, as the user is not logged in yet
		r.Post("/auth", user_api.Login)
		r.Head("/unique", user_api.CheckExists)

		r.Group("", func() {
			r.Get("", user_api.GetAll)
			r.Post("", user_api.Create)
			r.Get("/me", user_api.GetMe)
			r.Get("/search", user_api.Search)
			r.Post("/logout", user_api.Logout)

			r.Group("/{username}", func() {
				r.Patch("/password", user_api.UpdatePassword)
				r.Patch("/admin", user_api.SetAdmin)
				r.Patch("/active", user_api.Activate)
				r.Patch("/fullName", user_api.ChangeDisplayName)
				r.Delete("", user_api.Delete)
			})
		}, router.RequireSignIn)
	})

	// Share
	r.Group("/share", func() {
		r.Post("/file", file_api.CreateFileShare)
		r.Group("/{shareId}", func() {
			r.Get("", file_api.GetFileShare)
			r.Patch("/public", router.RequireSignIn, file_api.SetSharePublic)
			r.Delete("", router.RequireSignIn, file_api.DeleteShare)

			r.Group("/accessors", func() {
				r.Post("", file_api.AddUserToShare)
				r.Patch("/{username}", file_api.SetShareAccessors)
				r.Delete("/{username}", file_api.RemoveUserFromShare)
			})
		})
	})

	// ApiKeys
	r.Group("/keys", func() {
		r.Get("", user_api.GetMyTokens)
		r.Post("", user_api.CreateApiKey)
		r.Delete("/{keyId}", user_api.DeleteToken)
	}, router.RequireSignIn, router.RequireCoreTower)

	// Servers
	r.Group("/tower", func() {
		r.Post("/init", tower_api.InitializeTower)
		r.Group("", func() {
			r.Post("/reset", router.RequireOwner, tower_api.ResetServer)
			r.Post("/remote", tower_api.AttachRemote)
			r.Get("", tower_api.GetRemotes)

			r.Get("/backup", history_api.DoFullBackup)

			r.Post("/{serverId}/backup", backup_api.LaunchBackup)
			// r.Post("/{serverId}/restore", restoreToCore)
			// r.Patch("/{serverId}", updateRemote)
			r.Delete("/{serverId}", tower_api.DeleteRemote)
		}, router.RequireAdmin)
	})

	return r
}

func Docs() http.Handler {
	// Kinda hacky, but allows for docs to be served from /docs/ instead of /docs/index.html
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		if req.RequestURI == "/docs/" {
			req.RequestURI = "/docs/index.html"
		}

		httpSwagger.WrapHandler(w, req)
	})
}
